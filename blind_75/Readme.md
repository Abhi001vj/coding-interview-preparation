# Coding Interview Learning Path

Welcome to the **Coding Interview Learning Path** repository! This repo is intended to help anyone preparing for coding interviews by providing curated resources, structured guidance, and insightful strategies to tackle popular coding problems effectively.

## Quick Links
- [LeetCode Excel Sheet](https://docs.google.com/spreadsheets/d/17S7OZYJUf5Sm7HgbGBgq5Fc0sIC8_A0kymL4ijSYbCQ/edit?gid=0) - A curated list of LeetCode problems organized by topic.
- YouTube Video Guides:
  - [Coding Interview Patterns Overview - Part 1](https://www.youtube.com/watch?v=X-OcFNzZZxQ&t=428s)
  - [Coding Interview Patterns Overview - Part 2](https://www.youtube.com/watch?v=yWrXbYqdDGI)

## Overview

This learning path is designed using a combination of LeetCode problems, YouTube video tutorials, and useful links for foundational patterns. It covers different types of problems and techniques commonly tested during coding interviews. Whether you're just starting or want to refine your skills, this resource will help you master the essential patterns and problem-solving approaches for coding interviews.
# Coding Interview Learning Path

Welcome to the **Coding Interview Learning Path** repository! This repository provides structured guidance for coding interview preparation through curated resources and proven problem-solving patterns.

## Pattern Recognition Guide

When approaching coding problems, consider these patterns based on problem characteristics:

### Input Characteristics
- **Sorted Array**: Use Binary Search or Two Pointers
- **Permutations/Subsets**: Apply Backtracking
- **Trees**: Implement DFS/BFS traversal
- **Graphs**: Use DFS/BFS algorithms
- **Linked Lists**: Utilize Two Pointers technique
- **No Recursion Allowed**: Implement Stack-based solution
- **In-place Requirements**: Use value swapping or pointer manipulation
- **Max/Min Subarray/Subset**: Apply Dynamic Programming
- **Top/Least K Elements**: Use Heap or QuickSelect
- **Common Strings**: Implement Map or Trie
- **General Optimization**: 
  - O(1) time & O(n) space: Use Map/Set
  - O(nlogn) time & O(1) space: Sort input

## LeetCode Patterns based on keywords

- If input array is sorted then 
    - Binary search
    - Two pointers
- If asked for all permutations/subsets then
    - Backtracking
- If given a tree then
    - DFS
    - BFS
- If given a graph then
    - DFS
    - BFS
- If given a linked list then
    - Two pointers
- If recursion is banned then
    - Stack
- If must solve in-place then
    - Swap corresponding values
    - Store one or more different values in the same pointer
- If asked for maximum/minimum subarray/subset/options then
    - Dynamic programming
- If asked for top/least K items then
    - Heap
    - QuickSelect
- If asked for common strings then
    - Map
    - Trie
- Else
    - Map/Set for O(1) time & O(n) space
    - Sort input for O(nlogn) time and O(1) space
    
## Key Resource Links

### Algorithm Patterns
- Fast & Slow Pointer: [Floyd's Cycle Detection](https://www.geeksforgeeks.org/floyds-cycle-finding-algorithm/)
- Merge Intervals: [LeetCode Guide](https://leetcode.com/problems/merge-intervals/)
- Sliding Window: [Educative.io Pattern](https://www.educative.io/collection/page/5668639101419520/5671464854355968/5715943031947264)
- Matrix Traversal: [Number of Islands](https://www.geeksforgeeks.org/find-number-of-islands/)
- Two Pointers: [LeetCode Pattern](https://leetcode.com/explore/learn/card/two-pointer/)

### Advanced Techniques
- Cyclic Sort: [GeeksforGeeks Guide](https://www.geeksforgeeks.org/cyclic-sort/)
- Linked List Reversal: [LeetCode Implementation](https://leetcode.com/problems/reverse-linked-list/)
- Graph Traversal:
  - [BFS Algorithm](https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/)
  - [DFS Algorithm](https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/)
- Two Heaps: [Educative Pattern](https://www.educative.io/collection/page/5668639101419520/5671464854355968/5762960973213696)
- Subsets: [Subsets - LeetCode](https://leetcode.com/problems/subsets/)
- Modified Binary Search: [GeeksforGeeks Variations](https://www.geeksforgeeks.org/binary-search/)
- Bitwise XOR: [Bitwise Operators - GeeksforGeeks](https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/)
- Top ‘K’ elements: [Top K Elements - Educative](https://www.educative.io/collection/page/5668639101419520/5671464854355968/5671464856160256/)
- K-way Merge: [K-way Merge - GeeksforGeeks](https://www.geeksforgeeks.org/merge-k-sorted-arrays/)



### Dynamic Programming & Advanced Topics
- Knapsack Problems:
  - [0/1 Knapsack](https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/)
  - [Unbounded Knapsack](https://www.geeksforgeeks.org/unbounded-knapsack-repetition-items-allowed/)
- Graph Algorithms: [Topological Sort](https://www.geeksforgeeks.org/topological-sorting/)
- Stack Patterns: [Monotonic Stack Guide](https://leetcode.com/discuss/study-guide/1117284/monotonic-stack-101-the-detailed-guide-for-beginners)
- Backtracking: [Algorithm Overview](https://www.geeksforgeeks.org/backtracking-algorithms/)

## Learning Structure

The repository organizes problems into key categories:

1. **Arrays & Hashing**: hashMap, swapping, Sorting
2. **Two Pointers**: linkedlist, shringing window
3. **Sliding Window**: finding a subarray, or range
4. **Stack**: Monotonic Array, LCFS
5. **Binary Search**: Sorted
6. **Linked List**: Pointers
7. **Trees**: DFS & BFS
8. **Heap / Priority Queue**: top/least K items
9. **Intervals**: 
10. **Backtracking**:
11. **1-D Dynamic Programming**: maximum/minimum subarray/subset/options
12. **2-D Dynamic Programming**: maximum/minimum subarray/subset/options
13. **Graphs**: DFS & BFS
14. **Advanced Graphs**: DFS & BFS
15. **Greedy**:
16. **Tries**: Dictionary, Alphabetically sorted situations, phone book search
17. **Math & Geometry**:
18. **Bit Manipulation**:


## Contributing

Feel free to submit pull requests to add resources, patterns, or problem solutions. Please ensure additions are well-documented and include relevant examples.
## Learning Structure

The resources are organized into categories, covering various data structures and algorithms. Each category includes problem-solving techniques, video explanations, and direct links to the problems.

### Topics Covered:
1. **Arrays**
   - Problems like Two Sum, Maximum Subarray, and Search in Rotated Sorted Array.
   - Techniques: HashMaps, Sliding Windows, Prefix Sum, Two Pointers.
   - Links to problems and video solutions for better understanding.

2. **Binary**
   - Problems involving bit manipulation like Sum of Two Integers and Reverse Bits.
   - Techniques: Using bitwise operations to perform tasks efficiently.

3. **Dynamic Programming**
   - Classic problems like Climbing Stairs, Coin Change, and House Robber.
   - Techniques: Subproblems, Memoization, and Bottom-up approaches.

4. **Graphs**
   - Problems such as Clone Graph, Course Schedule, and Number of Islands.
   - Techniques: Depth-First Search (DFS), Breadth-First Search (BFS), Adjacency Lists.

5. **Linked Lists**
   - Problems like Reverse a Linked List, Detect Cycle in a Linked List, and Merge Sorted Lists.
   - Techniques: Fast and slow pointers, Merge using two pointers.

6. **Tree**
   - Problems such as Maximum Depth of Binary Tree, Binary Tree Level Order Traversal, and Subtree of Another Tree.
   - Techniques: Recursive and iterative DFS and BFS.

7. **Heap**
   - Problems like Merge K Sorted Lists, Top K Frequent Elements, and Find Median from Data Stream.
   - Techniques: Min-Heap, Max-Heap for efficient element retrieval.

8. **Intervals**
   - Problems like Merge Intervals, Insert Interval, and Meeting Rooms.
   - Techniques: Sorting intervals, Merge overlapping intervals.

9. **String**
   - Problems like Valid Parentheses, Minimum Window Substring, and Longest Palindromic Substring.
   - Techniques: Sliding Window, HashMaps, Two Pointers.

# 75 Essential LeetCode Problems

| No. | Category | Problem | Technique | Notes |
|-----|----------|----------|-----------|--------|
| **Arrays** |
| 1 | Arrays | Two Sum | HashMap | Use hash map to check for difference value |
| 2 | Arrays | Best Time to Buy and Sell Stock | Sliding Window | Find local min and search for local max |
| 3 | Arrays | Contains Duplicate | HashMap | Use hashset for unique values |
| 4 | Arrays | Product of Array Except Self | Array Traversal | Make two passes: prefix and postfix product |
| 5 | Arrays | Maximum Subarray | Prefix Sum | Previous subarray can't be negative |
| 6 | Arrays | Maximum Product Subarray | DP & Prefix | Compute curMax and curMin for each prefix |
| 7 | Arrays | Find Minimum in Rotated Sorted Array | Binary Search | Min present in unsorted part |
| 8 | Arrays | Search in Rotated Sorted Array | Binary Search | Check if target falls in left/right side |
| 9 | Arrays | 3Sum | Two Pointers | Sort input, use two pointers technique |
| 10 | Arrays | Container With Most Water | Two Pointers | Shrinking window from endpoints |
| **Binary** |
| 11 | Binary | Sum of Two Integers | Bit Manipulation | Add bit by bit with carry |
| 12 | Binary | Number of 1 Bits | Bit Manipulation | Use bit shift and bitwise & |
| 13 | Binary | Counting Bits | Pattern Recognition | Use biggest power of 2 ≤ i |
| 14 | Binary | Missing Number | XOR/Sum | XOR n with each index and value |
| 15 | Binary | Reverse Bits | Bit Manipulation | Reverse each of 32 bits |
| **Dynamic Programming** |
| 16 | DP | Climbing Stairs | Fibonacci | Use n and n-1 as base values |
| 17 | DP | Coin Change | Top-down/Bottom-up | Cache previous coin counts |
| 18 | DP | Longest Increasing Subsequence | DP | Track subsequence length ending with each number |
| 19 | DP | Longest Common Subsequence | DP | Compare first chars, cache results |
| 20 | DP | Word Break | DP | Cache results of wordbreak for substrings |
| 21 | DP | Combination Sum | Decision Tree | Use decision tree visualization |
| 22 | DP | House Robber | Two Variables | Track current and previous values |
| 23 | DP | House Robber II | Circular DP | Apply House Robber on two subarrays |
| 24 | DP | Decode Ways | DP | Handle one and two digit decodings |
| 25 | DP | Unique Paths | Bottom-up | Work backwards from solution |
| 26 | DP | Jump Game | Greedy/DP | Work backwards to check reachability |
| **Graph** |
| 27 | Graph | Clone Graph | DFS | Use hashmap for visited nodes |
| 28 | Graph | Course Schedule | DFS | Detect cycles in directed graph |
| 29 | Graph | Pacific Atlantic Water Flow | DFS | Track cells reaching both oceans |
| 30 | Graph | Number of Islands | DFS/BFS | Count connected components |
| 31 | Graph | Longest Consecutive Sequence | HashSet | Check consecutive numbers in set |
| 32 | Graph | Alien Dictionary | Topological Sort | Build graph from word order |
| 33 | Graph | Graph Valid Tree | Union-Find/DFS | Check connectivity and cycles |
| 34 | Graph | Number of Connected Components | DFS/BFS | Count separate components |
| **Interval** |
| 35 | Interval | Insert Interval | Merge | Insert and merge overlapping intervals |
| 36 | Interval | Merge Intervals | Sort | Sort and merge overlapping intervals |
| 37 | Interval | Non-overlapping Intervals | DP | Count max non-overlapping intervals |
| 38 | Interval | Meeting Rooms | Sort | Sort by start time |
| 39 | Interval | Meeting Rooms II | Min Heap | Track concurrent meetings |
| **Linked List** |
| 40 | LinkedList | Reverse Linked List | Two Pointers | Maintain current and previous |
| 41 | LinkedList | Detect Cycle | Fast/Slow Pointers | Floyd's cycle detection |
| 42 | LinkedList | Merge Two Sorted Lists | Two Pointers | Use dummy head node |
| 43 | LinkedList | Merge K Sorted Lists | Divide & Conquer | Use priority queue |
| 44 | LinkedList | Remove Nth Node From End | Two Pointers | Maintain n-gap between pointers |
| 45 | LinkedList | Reorder List | Split & Merge | Split, reverse second half, merge |
| **Matrix** |
| 46 | Matrix | Set Matrix Zeroes | Sets | Track rows/cols to zero |
| 47 | Matrix | Spiral Matrix | Boundaries | Track layer boundaries |
| 48 | Matrix | Rotate Image | Layer by Layer | Rotate positions in groups |
| 49 | Matrix | Word Search | DFS | Track visited cells |
| **String** |
| 50 | String | Longest Substring Without Repeating | Sliding Window | Track duplicate chars |
| 51 | String | Longest Repeating Character Replacement | Sliding Window | Track char frequencies |
| 52 | String | Minimum Window Substring | Sliding Window | Track char counts |
| 53 | String | Valid Anagram | HashMap | Count chars in both strings |
| 54 | String | Group Anagrams | HashMap | Use char counts as key |
| 55 | String | Valid Parentheses | Stack | Match opening/closing braces |
| 56 | String | Valid Palindrome | Two Pointers | Compare alphanumeric chars |
| 57 | String | Longest Palindromic Substring | Expand Around Center | Check odd/even lengths |
| 58 | String | Palindromic Substrings | Expand Around Center | Count all palindromes |
| 59 | String | Encode and Decode Strings | Length Encoding | Store length before string |
| **Tree** |
| 60 | Tree | Maximum Depth of Binary Tree | DFS/BFS | Count levels |
| 61 | Tree | Same Tree | DFS | Compare structures recursively |
| 62 | Tree | Invert Binary Tree | DFS/BFS | Swap children recursively |
| 63 | Tree | Binary Tree Maximum Path Sum | DFS | Track split vs non-split paths |
| 64 | Tree | Binary Tree Level Order Traversal | BFS | Process level by level |
| 65 | Tree | Serialize and Deserialize Binary Tree | BFS | Include null children |
| 66 | Tree | Subtree of Another Tree | DFS | Check equality at each node |
| 67 | Tree | Construct Binary Tree from Traversals | Recursion | Use pre/inorder properties |
| 68 | Tree | Validate Binary Search Tree | DFS | Track min/max bounds |
| 69 | Tree | Kth Smallest in BST | Inorder | Track k during traversal |
| 70 | Tree | Lowest Common Ancestor of BST | BST Property | Compare node values |
| 71 | Tree | Implement Trie | Trie | Store children chars |
| 72 | Tree | Add and Search Word | Trie | Handle wildcard chars |
| 73 | Tree | Word Search II | Trie + DFS | Store dictionary in trie |
| **Heap** |
| 74 | Heap | Merge K Sorted Lists | Min Heap | Track k frontiers |
| 75 | Heap | Top K Frequent Elements | Min Heap | Maintain k largest |