https://leetcode.com/discuss/interview-question/6137101/Google-L3-interview-experience
Google L3 interview experience
2
Anonymous User
Anonymous User
December 12, 2024 12:32 AM

510 VIEWS

Hello everyone,


I recently appeared for the Google L3 interviews and wanted to share my experience with all of you.


1st Onsite Round (9th September)
The interviewer was very helpful, and we started with introductions. The first question was related to n-ary trees, which could be solved using DFS and backtracking. I was able to discuss the solution and code it within 10 minutes.


The follow-up question was also related to trees, where the n-ary tree was converted into a graph, and the problem boiled down to union-find. I discussed and coded this solution in about 15 minutes.


In the next 10 minutes, we discussed the implementation of Kosaraju's Algorithm and concluded the interview by talking about work at Google Search.


Key Learnings from this Interview:
Google questions are very open-ended, so it's crucial to thoroughly discuss the problem with the interviewer.
Writing modular and clean code is an essential evaluation parameter at Google.
Outcome:
The next day, the recruiter called to inform me that the feedback from this interview was very positive.
My Self-Rating: Strong Hire (SH)


2nd Onsite Round (11th September)
The interviewer joined late and jumped straight into DSA.


The first question was related to graphs and DP, involving a matrix where water starts falling from each point, and the task was to find the point where the water would get stored. I applied DFS and DP, and the implementation was quite extensive, taking around 15 minutes to complete.


The follow-up question involved storing the list of points where the water would be collected. While the logic was similar, it required using a proper data structure. I used maps to store the values and completed the code within the next 10 minutes.


The interviewer pointed out a redundancy in my code, which I corrected during our discussion. We then analyzed the time and space complexity of the solution.


With 5 minutes remaining, we had a brief discussion about the perks of working at Google.


Key Learnings from this Interview:


Typing speed is critical, as you need to complete two questions within 40 minutes. Participating in time-constrained contests proved to be a significant advantage for me.
Outcome:
My Self-Rating: Hire/Strong Hire (H/SH)


Rescheduling Experience
Before my third onsite round, the interview schedule was changed around 5–6 times, which became quite frustrating for me.


3rd Onsite Round (30th September)
This round happened while I was on-call at my current company and already quite tired. The interviewer joined late and immediately started with a DSA question.


The question was related to binary search, where we had to find pivot elements in an array containing duplicates. Unfortunately, I struggled during this round. I made several mistakes in the implementation, and each time I thought my code was correct, the interviewer pointed out an edge case that I had missed.


Overall, I wasn’t satisfied with my performance in this round. However, the interviewer appreciated that I kept interacting, discussing ideas, and trying out different implementations despite the challenges. Toward the end, he remarked, "Jao cricket dekho" (Go watch cricket). We both laughed and had a lighthearted conversation about Google.


Key Takeaway:


Sometimes, it’s just not your day. Staying positive and maintaining a good rapport with the interviewer can still leave a lasting impression.
Outcome:
My Self-Rating: Lean Hire/Lean No Hire (LH/LNH)


4th Onsite Round (Googliness)
This round was a friendly and conversational session. We discussed various scenarios and how I would respond to them in the context of working at Google.


I was able to confidently answer all the questions, leveraging the STAR (Situation, Task, Action, Result) pattern to structure my responses effectively.


Outcome:
My Self-Rating: Hire/Strong Hire (H/SH)


Recruiter Update (9th October)
The recruiter informed me that three rounds received positive ratings, while one had mixed feedback. They mentioned proceeding to the team-matching stage, with the final decision resting with the Hiring Committee (HC).


Team Matching Round 1 (15th October)
This round was with the Google Search Ads team manager. We discussed the team’s work and my past projects. I felt confident about the round, but the recruiter later shared that the manager put my profile on hold as he was still considering other candidates.


Then came a lot of waiting.


Team Matching Round 2 (15th November)
The second team-matching round was with a YouTube team manager. The manager was friendly, and we discussed the team’s work and my past projects. I found their work quite interesting and aligned with my interests.


Within 30 minutes of the interview, the recruiter called to inform me that the manager wanted to move forward with my profile. The final decision would now be with the Hiring Committee (HC).


Final Outcome
One week later, I received a call from the recruiter with great news: I had passed the HC review! We discussed the compensation, and I signed the offer letter on 26th November.


My Key Learnings:


Patience is key. Google’s hiring process takes time, and you need to trust it.
One bad day isn’t the end. Keep working hard, and good things will come your way.
Consistency matters. One LeetCode question a day brings Google closer—practice consistently and stay prepared.




https://leetcode.com/discuss/interview-question/6072539/Google-Elimination-Round-Interview-Experience
Google Elimination Round Interview Experience
2
Anonymous User
Anonymous User
Last Edit: November 22, 2024 11:04 PM

480 VIEWS

First Round was of almost 1 hour because interviewer came late, though it was officially just for 45 minutes.
It happened on 12th November.


I was asked a dp question in the form of a complex story like a game between alice and bob.
To figure out the question itself took me a long time.
I asked a lot of clarifying questions before doing anything.
Once i understood the question i immediately came up with a recursive approach for the problem and it was quite accurate. It was a variation of the frog jump problem on leetcode but was actually not that straightforward.
The interviewer asked me to optimize it so i quickly told him we can use dp memoization.
He asked me which states will you actually memoize. I got a bit confused here. So he quickly asked me to code maybe then i would get some clarity.
I started coding and was able to write the code. Then i missed a couple of things like we had to take turns to actually make the jump, once we make the jump, the second time we don't so i missed that and completely changed my code later.
This made him quite happy because i wrote a very clean code with probably no errors. After that he asked me to optimize it so i quickly memoized the turn and index states and wallah i wrote both brute and optimal for an actually hard problem. This made interviewer quite happy and i got selected for the 3 technical rounds.
Problem level i would say medium to hard.

google
india
dp
google interview
was it this ques?
https://leetcode.com/discuss/interview-question/5962545/Google-Screening-Round-or-L4-or-Game-theory-or-oct-2024/



and can you please your solution here?

0
Show 2 replies
Reply
Share
Report
Khushil-6's avatar
Khushil Prajapati
4
November 23, 2024 8:21 PM

Read More
Was the question similar to the one asked in this post for Round 2: https://leetcode.com/discuss/interview-question/6061888/Google-or-SWE-or-On-campus-Hiring-or-Rejected

0
Show 1 reply
Reply
Share
Report

https://leetcode.com/discuss/interview-question/6061888/Google-or-SWE-or-On-campus-Hiring-or-Rejected
Google | SWE | On campus Hiring | Rejected
29
Anonymous User
Anonymous User
November 19, 2024 4:10 PM

4.2K VIEWS

Round 1 (45 Mins):


Given an undirected graph with some faulty nodes where you are not allowed to visit. Is it possible to reach from node A to node B?


Follow up: If we consider the cost to be 1 of each teleportation what’s the minimum cost?
Follow up: if we can repair the node by paying amount C (C can be different for each faulty node). What's the minimum cost now?
Follow up: if we can repair the node by paying amount C (same cost for all faulty nondes.). and all other nodes are free to travel, what's the cost now?


Round 2 (1 Hour):


Given an undirected graph, Alice and Bob are standing somewhere (node index is given), They want to reach a common destination D such that the number of unique edges they traverse is as minimum as possible. (Most hops should be common.!)


Googliness:


One of the ambitions which you were able to accomplish!
One of the ambitions, which you were not able to accomplish!
and some follow-ups..


Round 3 (1 Hour):


K window of a list = distinct elements in the first K elements
Given 2 lists, modify list2 such that the k windows of the 2 lists don't have any common element. Return the new list (Asked to optimize the space multiple times).


Variation:
Instead of 2 lists we have n lists, and a distance parameter d, the k window of a list shouldn't have any common element with any of the previous 'd' lists. Return the new lists


Googliness:


Tell me about a time where you had to incorporate feedback from your team as well as users of your application.
How do you manage a deadline if you know you can’t complete the assigned work?
Suppose, you are a team leader and one of your team members is not supporting your views but other people are! How would you handle it?
google
india
Comments: 14
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
Teut's avatar
Vishesh Mangla

74
November 20, 2024 9:30 PM

Read More
Googliness:


Tell me about a time where you had to incorporate feedback from your team as well as users of your application.
How do you manage a deadline if you know you can’t complete the assigned work?
Suppose, you are a team leader and one of your team members is not supporting your views but other people are! How would you handle it?
What sort of crappy questions are these and what is google expecting from new grads?

11
Show 1 reply
Reply
Share
Report
nivedha's avatar
nivedha rajaram

11
Last Edit: November 20, 2024 2:33 AM

Read More
from collections import deque, defaultdict

def can_reach(graph, faulty_nodes, A, B):
    if A in faulty_nodes or B in faulty_nodes:
        return False  
    visited = set()
    queue = deque([A])
    visited.add(A)
    
    while queue:
        current = queue.popleft()
        if current == B:
            return True
        for neighbor in graph[current]:
            if neighbor not in visited and neighbor not in faulty_nodes:
                visited.add(neighbor)
                queue.append(neighbor)
    
    return False
if __name__ == "__main__":
    graph = defaultdict(list)
    edges = [
        ('A', 'x'),
        ('x', 'y'),
        ('y', 'D'),
        ('B', 'y'),
    ]
    
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)  
    
    faulty_nodes = {'z'}  
    A = 'A'
    B = 'D'
    
    min_steps = min_teleportations(graph, faulty_nodes, A, B)
    print("Minimum Teleportations:", min_steps)

Follow up: If we consider the cost to be 1 of each teleportation what’s the minimum cost?
def min_teleportations(graph, faulty_nodes, A, B):

    if A in faulty_nodes or B in faulty_nodes:
        return -1  
    
    visited = set()
    queue = deque([(A, 0)])  
    visited.add(A)
    
    while queue:
        current, distance = queue.popleft()
        if current == B:
            return distance
        for neighbor in graph[current]:
            if neighbor not in visited and neighbor not in faulty_nodes:
                visited.add(neighbor)
                queue.append((neighbor, distance + 1))
    
    return -1  
Follow up: if we can repair the node by paying amount C (C can be different for each faulty node). What's the minimum cost now?
import heapq

def min_total_cost_varying(graph, faulty_nodes, repair_costs, A, B):

    
    heap = []
    heapq.heappush(heap, (0, A))
    

    min_cost = {}
    min_cost[A] = 0
    
    while heap:
        current_cost, current_node = heapq.heappop(heap)
        
        if current_node == B:
            return current_cost
        

        for neighbor in graph[current_node]:
            if neighbor in faulty_nodes:
                repair_cost = repair_costs.get(neighbor, float('inf'))
                new_cost = current_cost + 1 + repair_cost  
               
                if neighbor not in min_cost or new_cost < min_cost[neighbor]:
                    min_cost[neighbor] = new_cost
                    heapq.heappush(heap, (new_cost, neighbor))
            else:
                new_cost = current_cost + 1
                if neighbor not in min_cost or new_cost < min_cost[neighbor]:
                    min_cost[neighbor] = new_cost
                    heapq.heappush(heap, (new_cost, neighbor))
    
    return -1  

Follow up: if we can repair the node by paying amount C (same cost for all faulty nondes.). and all other nodes are free to travel, what's the cost now?
def min_total_cost_uniform(graph, faulty_nodes, C, A, B):

    heapq.heappush(heap, (0, A))
    
    min_cost = {}
    min_cost[A] = 0
    
    while heap:
        current_cost, current_node = heapq.heappop(heap)
        
        if current_node == B:
            return current_cost
        
       for neighbor in graph[current_node]:
            if neighbor in faulty_nodes:
                new_cost = current_cost + 1 + C  # 1 for teleportation + C for repair
                
                if neighbor not in min_cost or new_cost < min_cost[neighbor]:
                    min_cost[neighbor] = new_cost
                    heapq.heappush(heap, (new_cost, neighbor))
            else:
                 new_cost = current_cost + 1
                if neighbor not in min_cost or new_cost < min_cost[neighbor]:
                    min_cost[neighbor] = new_cost
                    heapq.heappush(heap, (new_cost, neighbor))
    
    return -1 
K window of a list = distinct elements in the first K elements
Given 2 lists, modify list2 such that the k windows of the 2 lists don't have any common element. Return the new list (Asked to optimize the space multiple times).

def modify_list2(list1, list2, K):

    window1 = set(list1[:K])
    window2 = set(list2[:K])

    common = window1.intersection(window2)
    
    if not common:
        return list2  # No modification needed    
    import string
    available_elements = set(string.ascii_lowercase) - window1 - set(list2)
    if len(available_elements) < len(common):
        raise ValueError("Not enough unique elements to replace.")
    
    replacement_iter = iter(available_elements)
    
    modified_list2 = list2.copy()
    window2_list = list2[:K]
    
    for idx in range(K):
        elem = modified_list2[idx]
        if elem in common:
            new_elem = next(replacement_iter)
            modified_list2[idx] = new_elem
            common.remove(elem)
            if not common:
                break  # All conflicts resolved
    
    return modified_list2
Variation:
Instead of 2 lists we have n lists, and a distance parameter d, the k window of a list shouldn't have any common element with any of the previous 'd' lists. Return the new lists
def modify_n_lists(lists, K, D):

    import string
    available_pool = iter(string.ascii_lowercase)
       sliding_windows = []
    
    for i, current_list in enumerate(lists):
        current_window = set(current_list[:K])
        
         conflict_elements = set()
        for prev_window in sliding_windows:
            conflict_elements.update(prev_window)
        
           common = current_window.intersection(conflict_elements)
        
        if common:
            available_elements = set(string.ascii_lowercase) - conflict_elements - current_window
            if len(available_elements) < len(common):
                raise ValueError(f"Not enough unique elements to replace in list {i+1}.")
            replacement_iter = iter(available_elements)
            
            for idx in range(len(current_list)):
                if current_list[idx] in common:
                    new_elem = next(replacement_iter)
                    current_list[idx] = new_elem
                    common.remove(current_list[idx])
                    if not common:
                        break  # All conflicts resolved
        
       current_window = set(current_list[:K])
        sliding_windows.append(current_window)
        if len(sliding_windows) > D:
            sliding_windows.pop(0)
    
    return lists

4
Show 1 reply
Reply
Share
Report
leetcode_userr's avatar
Leetcode user
371
November 19, 2024 7:53 PM

Read More
Round 2 question is dicusssed here: https://leetcode.com/discuss/interview-question/5748871/

2
Show 1 reply
Reply
Share
Report
BiggestChungus's avatar
Big Chungus

1680
November 22, 2024 5:08 PM

Read More
R2 is a fun one, it's on LC somewhere but around free problem number 1700 or so, it's obscure.


It can be solved in 3 passes of BFS and a final scan over all nodes. Let the min cost path be


Alice (A) moves to some common node (C)
Bob (B) moves to the same common node
then they both travel from the common node to the destination node (D)
Do a pass of BFS starting from D to get the distance of D to all nodes. If A or B is unreachable return immediately. Then do two more passes to get the distances from A and B to all other nodes.


Then we can write the path as


the cost of Alice to reach some first common node C, alice_distances[C]
plus the cost of Bob to reach that same node, bob_distances[C]
plus the cost to go from C to D: dest_distances[C]
the C that minimizes this sum is the optimal solution.
Note that not all C are valid, e.g. C might be later than the ideal common node; the A-C and B-C routes may have another, earlier node C' in common. But that will be fine because cost(C') < cost(C) - same path, but the C'-C edges won't be double-counted. Therefore not all A/B/C/D combos are valid, but the minimum cost combo is valid.


R3 followup looks hard.


For the first part I'm assuming any rearrangement of list2 is acceptable since a cost metric isn't stated. We can


make a set of the K window of the first list, call it banned
start two lists for the modified list2, call them front and back
add the second list's elements to front or back depending on whether the value is in banned
this is basically the opposite of a mergesort; we're splitting list2 into two new lists, then we'll merge the lists at the end
Maybe like this, TC O(L1 + L2), SC O(k) since I'm reusing the input nodes, just rearranging their links


def shuffleList2(list1, list2, k):
    preFront = Node()
    tailFront = preFront

    preBack = Node()
    tailBack = preBack

    banned = set()
    curr = list1
    for _ in range(k):
        if not curr: break
        banned.add(curr.val)
        curr = curr.next

     curr = list2
     while curr:
         if k and curr.val not in banned: # can put this in k-window of list2
             frontBack.next = curr
             frontBack = curr
             k -= 1
         else:
             tailBack.next = curr
             tailBack = curr

         curr = curr.next

     if k: raise ValueError("Impossible")

     tailBack.next = None # avoid dangling pointer
     frontBack.next = preTail.next # append back to front
     return preFront.next
The followup is more interesting and I guess a lot harder. Having lots of distinct elements in the k-windows makes violating the constraint more likely, so in general if we pick some value v to be in the k-window of list i, we should take all the copies we can.


Consequently we can brute-force the problem with DFS+BT


for the current list we need to consider all possible k-windows
then for each next list we need to update the constraint - all uniques that appear in the prior d lists' k-windows
This solves the hardest part of satisfying the constraints. Once we have valid k-windows for all lists we can do something similar to the original problem to form the output lists.


Something like this (untested, probably has bugs and typos), TC exponential I think, SC O(N*k). Somewhat complicated form of DFS+BT because we need to do some additional work for fill(i, 0, k): when we start considering i, we are no longer bound by the elements in the list d+1 ago if any. But if we return False because an arrangement isn't possible, if j=0, we're unwinding the stack to the prior list, and thus we become bound by the elements in list i-d-1 again.


def rearrangeLists(lists: list[list[int]], d: int, k: int) -> list[list[int]]:
    N = len(lists)

    if any(len(l) < k for l in lists): return [] # not possible to form a k-window with less than k elements

    banned = {} # contains the uniques among the prior d lists and their frequencies
    taken = [{} for _ in range(N)] # uniques and counts of elements in each k-window
    freqs = [list(Counter(l).items()) for l in lists] # all uniques and counts for all lists (yikes)

    def add(v: int, f: int, d: dict): # adds f copies of v to the given dictionary of counts
        d[v] = d.get(v, 0) + f

    def rem(v: int, f: int, d: dict): # removes f copies of v from the given dictionary; removes v if 0 copies remain (makes backtracking easier)
        d[v] -= f
        if not d[v]: del d[v]

    # fills in `picked` so we get the k-windows; we follow up with list creation at the end
    def fill(i: int, j: int, r: int) -> bool:
        if i == N: return True # we made it to the end
        if r == 0: return fill(i+1, 0, k) # continue with next list
        if j == len(freqs[i]): return False # couldn't take k values without violating rules, we must backtrack

        if j == 0 and i-d-1 >= 0:
            for v, f in picked[i-d-1].items(): rem(v, f, banned) # these elements are no longer within d lists

        v, f = freqs[i][j]

         if v not in banned:
             # tentatively take as many copies of v as we can, up to the remaining values we need r
             t = min(f, r)
             add(v, t, picked[i])
             add(v, t, banned)
             if fill(i, j+1, r-t): return True
             # backtrack
             rem(v, t, picked[i])
             rem(v, t, banned)

         # also consider not taking v
         if fill(i, j+1, r-t): return True
      
         # if backtracking to prior list we need to re-add the banned elements from list i-d-1
         if j == 0 and i-d-1 >= 0:
             for v, f in picked[i-d-1].items(): add(v, f, banned)

          return False

    possible= fill(i=0, j=0, r=k)
    if not possible: raise ValueError("Impossible")

    # build the output lists
    # for each list we put elements in the k-window in front, and append the rest to the back
    # TODO: it would be slightly faster and memory efficient to do a Yates-like shuffle, but
    #             we're already using O(n k) space so not a huge deal
    out = []
    for i, l in enumerate(lists):
        out.append([])
        pending = [] # where we put elements not in the k-window
        for v in l:
            if v in picked[l]: # append to k-window first
                out[-1].append(v)
                rem(v, 1, picked[l])
            else:
                pending.append(v)

         out[-1].extend(pending)

    return out
1
Show 1 reply
Reply
Share
Report
ashishhchaudharyy's avatar
ashishchaudhary

9
November 20, 2024 1:29 AM

Read More
what are you cf stats ? is doing cf necessary to clear google interview or oa ??

1
Show 1 reply
Reply
Share
Report
agXkQZQMWC's avatar
agXkQZQMWC
0
November 29, 2024 1:39 AM

Read More
What is your location?

0
Show 1 reply
Reply
Share
Report
Mrinal1886's avatar
MMcode

63
November 21, 2024 6:54 AM

Read More
Round 2 answer:


from collections import deque
from functools import cmp_to_key

class Graph:
    def __init__(self, n):
        self.n = n
        self.adj = [[] for _ in range(n + 1)]
    
    def add_edge(self, u, v):
        self.adj[u].append(v)
        self.adj[v].append(u)
    
    def bfs(self, start):
        """Perform BFS and return distances from the start node."""
        distance = [float('inf')] * (self.n + 1)
        distance[start] = 0
        queue = deque([start])
        
        while queue:
            u = queue.popleft()
            for v in self.adj[u]:
                if distance[v] == float('inf'):
                    distance[v] = distance[u] + 1
                    queue.append(v)
        return distance


class Solution:
    def __init__(self, n, edges, A, B, D):
        self.graph = Graph(n)
        for u, v in edges:
            self.graph.add_edge(u, v)
        self.A = A
        self.B = B
        self.D = D
    
    def calculate_min_unique_edges(self):
        """Calculate the minimum unique edges required."""
        distance_A = self.graph.bfs(self.A)
        distance_B = self.graph.bfs(self.B)
        distance_D = self.graph.bfs(self.D)
        
        min_unique_edges = float('inf')
        for node in range(1, self.graph.n + 1):
            if (
                distance_A[node] != float('inf') and
                distance_B[node] != float('inf') and
                distance_D[node] != float('inf')
            ):
                unique_edges = distance_A[node] + distance_B[node] + distance_D[node]
                min_unique_edges = min(min_unique_edges, unique_edges)
        return min_unique_edges


# Comparator for additional sorting logic (if required)
def node_comparator(node1, node2):
    # Example: sort by the sum of distances
    if node1.total_distance != node2.total_distance:
        return node1.total_distance - node2.total_distance
    return node1.id - node2.id


# Example Usage
def main():
    n = 5
    edges = [(1, 2), (2, 3), (3, 4), (5, 3)]
    A, B, D = 1, 5, 4
    
    solution = Solution(n, edges, A, B, D)
    result = solution.calculate_min_unique_edges()
    print(result)

if __name__ == "__main__":
    main()

0
Reply
Share
Report
baeasr's avatar
baeasr

16
November 20, 2024 7:28 PM

Read More
In question 1 what does it mean when you say "teleportation"? Thanks.

0
Show 1 reply
Reply
Share
Report
Neelgupta007's avatar
Neel

27
November 20, 2024 12:00 PM

Read More
Sorry, but round 3 question is not doable with the information that you have provided...
what type of operations needs to be performed.

0
Show 1 reply
Reply
Share
Report
m4x16's avatar
m4x16
21
November 20, 2024 1:00 AM

Read More
Did you get any followup for round2 ? If yes how did you solve that ?


https://leetcode.com/discuss/interview-question/6022021/Google-India-screening.
Google India screening.
6
Anonymous User
Anonymous User
Last Edit: November 9, 2024 9:58 PM

675 VIEWS

Hi LC community
had my fist google screening round today . the question was to build an integer which is maximum subsequnce from a subarray of size K. e.g Array is [4 , 9 , 0 , 2] and k = 2. asnwer 92 .
has never seen this before so gave a DP solution with memoization where i add my i'th index number to result and decrement k , or dont add and incremened index. gave TC as k X O(n) . interviewer was not happy asked me to optimized .
I gave an approach wehere i choose from left with atleast k-1 elemet to the right , then again take the max after that index. solved using heap , interviwere agreed but asked to optimize more and even gave a hint which i did not understood . basically i had to use monotonic stack and do it in O(n).
seems this is the end of my google journey for now .
thanks

google
heap
india
dp
monotonic stack
Comments: 8
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
icy_fyr's avatar
Akshay Kumar

16
November 10, 2024 2:42 AM

Read More
similar to this question : https://leetcode.com/problems/remove-k-digits/description/
just substitute k = n-k,
and inverse the condition of removing the elements from stack ( since u want overall max result)

6
Reply
Share
Report
DfcYPZWivX's avatar
DfcYPZWivX
2
November 8, 2024 4:10 PM

Read More
You gotta do it using monotonic-queue(not strict) instead..
Like 1st step is finding mono-queue from the left n - (k - 1) elements: 9->0->null, we take the largest element which is 9
Then we add n - kth element to mono-queue: 2->null and take the one which is on the back which is 2
In such way we can take the maximum in a range while making sure at least required amount of numbers are left outside of the queue

2
Show 1 reply
Reply
Share
Report
datowitzki's avatar
David Khanjaladze

4
November 8, 2024 2:33 PM

Read More
I got the same question, question was about to find subsequence, not subarray

1
Show 3 replies
Reply
Share
Report
user2249gu's avatar
Unnati
1
December 8, 2024 6:40 PM

Read More
For which location did you interview for?

0
Reply
Share
Report
gautamjivrajani's avatar
gautamjivrajani
1
November 16, 2024 12:48 PM

Read More
Hi,


I’d like to connect with you on LinkedIn to discuss this further. Please share your profile with a note if possible, so I can better understand your perspective.


Here’s my LinkedIn profile: Gautam Jivrajani.

0
Reply
Share
Report
dhruvp16011's avatar
LC_D_P

115
November 10, 2024 11:30 AM

Read More
arr = [4 , 9 , 0 , 2]
k = 2
#need to remoce n-k smallest elemnts will be left with k largest
st = []
k = len(arr)-k
for i in range(0,len(arr)):
    while st and k and arr[st[-1]] < arr[i]:
        st.pop()
        k-=1
    st.append(i)
st = st[:k] if k else st
ans = 0
for i in st:
    ans = ans *10 + arr[i]
print(ans)
0
Reply
Share
Report
Sumankr6's avatar
Sumankr6

9
Last Edit: November 8, 2024 6:40 PM

Read More
What is the time complexity of the heap approach which you gave ?
I think we can build a segment tree here to find {maxValue, Index} in some range(l,r). After then, we can look for the ith digit in the range (p, n-(k-i+1)) using segment Tree, where p is the position of the (i-1)th digit. The overall time complexity will be klog(n) and space complexity will be O(4*n).

0
Hide 1 reply
Reply
Share
Report
Anonymous User
Anonymous User
November 9, 2024 9:59 PM

Read More
I told him K * N , and he was disappointed I could see it on his face

0
Reply
Share
Report
bytesandbeyond_23's avatar
Sejal Rai

45
November 8, 2024 2:09 PM

Read More
9,0,2 , is subarray of size 3 right ? can you elaborate the question more?

0
Hide 1 reply
Reply
Share
Report
Anonymous User
Anonymous User
November 9, 2024 10:00 PM

Read More
Hi Sorry for the confusion, it was to find subsequence, not subarray.

0
Reply
Share
Report

https://leetcode.com/discuss/interview-question/5659307/Google-Interview-(-Ghosted-after-clearing-first-round-)

Google Interview ( Ghosted after clearing first round )
0
Anonymous User
Anonymous User
August 19, 2024 1:31 PM

622 VIEWS

Hi folks,


Just wanted to vent out a bit and get suggestions on what to do.


A Google recruiter reached out to me on LinkedIn and had a conversation over phone. He gave me 3 weeks to brush up all concepts. This was for L4. He also scheduled a mock interview which was really helpful.


Finally came the day of interview. It was preliminary round. Interviewer joined 10 min late. Spoiler! it went really well. We had a quick introduction and background chats. And then moved to coding questions.


I cannot share the questions, but 2 questions were LC Medium LinkedList and Tree questions. I was able to come up with an approach quickly and then there were couple of follow-up questions. I was able to handle all of the follow-ups and then was also able to quickly code them.


Since, we had about 4-5 min left, interviewer asked another question which I could only brainstorm and discuss approaches. He had multiple follow-ups. Later, I checked, it was similar to LC Hard question.


By the end, I asked some questions from interviewer and one of them was a quick feedback. Interviewer stated that I have good grasp on DSA and for next rounds just brush up system designs & architectures (As my background also involves solution architecture).


Few days later, I mailed the recruiter and recruiter immediately pinged me on LinkedIn that I have cleared the preliminary round and he will soon schedule next rounds.


Sadly, since then, it seems I got ghosted. I tried reaching out to him over mail and LinkedIn, but he is not responding. It has been about a month now since my day of interview. The application status is still same as before (Status: Interview Scheduled). I don't know what to do.


Should I continue following-up every week, or is it too rude to pester this frequent?
Should I apply for any other opening in Google, or does it negetively impact anything since an application is currently in progress?


Also, I'll be grateful if anyone here refer me in any other good product based company. Though, this is an anonymous post, so not sure how we can connect!!!



https://leetcode.com/discuss/interview-question/5631366/My-Google-Interview-Experience%3A-A-Journey-of-7-Interviews-and-Rejection

k
My Google Interview Experience: A Journey of 7 Interviews and Rejection
8
Anonymous User
Anonymous User
Last Edit: August 14, 2024 5:03 PM

1.2K VIEWS

My Google Interview Experience(L4): A Journey of 7 Interviews and Rejection
Hi everyone,
I’m writing this post just a few hours after receiving my rejection from Google. Although I'm feeling dejected right now, I have a strong belief that something better is waiting for me in the future. I wanted to share my experience to give you an insight into what it can be like to interview with Google.
The Beginning: A Glimmer of Hope
In January 2024, I received a call from a recruiter at Google. She wanted to know more about my current work and whether I was considering a change. At the time, I was already preparing for interviews because the growth opportunities at my current company were limited. The call from Google gave me hope and validated the hard work I’d been putting in—it felt like a sign that I was on the right path.
The recruiter asked when I could have my first interview. Since I had been preparing for the last six months, I told her I would be ready in two weeks, and we scheduled the first round.
The Interviews: A Rollercoaster of Emotions
I was nervous, having heard how challenging Google interviews can be, especially with their unique and high-level questions. During the first interview, I managed to solve the problem but got a bit confused when discussing time complexity. Despite this, I received positive feedback and advanced to the next round.
Over the next six months, I had four more interviews. Unfortunately, there was a two-month gap in communication because the recruiter forgot about me, and then I was assigned a new recruiter and a lot of rescheduling from there side becuase interviewers were not available(Interviewers didn't join the call twice). In those rounds, I received one "lean hire" and the rest were "hire" or "strong hire." However, due to the lean hire, the hiring committee decided to conduct one more round, which led to my rejection.
I also felt that the new recruiter wasn't particularly supportive. After the lean hire round, he informed me that I hadn't cleared the interview and added comments like, "Please don’t disappoint." In the end, I felt like that’s exactly what happened.
Reflection: A Learning Experience
The Google interview process felt like an overkill due to its length. I had been preparing for seven months, only to receive an email saying they couldn’t move forward with my application. It feels like all the effort and extra hours I put in were for nothing.
However, I believe that this might have happened for the best, and perhaps the best is yet to come. It’s going to take some time to get over this, but I hope that sharing my story might be helpful for those going through a similar situation. You are not alone.


For all the readers did you face any similar experience, is this something that is normal in Google interviews do let me know youe experiences .


Thank you

google
india
l4
Comments: 8
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
blahbar's avatar
Larry Braverman
356
August 13, 2024 10:14 PM

Read More
screw them... google has become incessant pool of negative interview experiences. Wonder who waits around for their BS

2
Reply
Share
Report
arpita_k_kumari's avatar
arpita_k_kumari

24
August 16, 2024 2:52 PM

Read More
I faced almost the same thing. I had 1 SH, 1 H, and 1 lean hire. Recruiter asked to give 2 more interviews out of which 1 was H and the other was LH. She rejected me because they expected both the rounds to be a SH/H. At that moment I felt like all the hard work I did in the past 6 months was for nothing.

1
Show 10 replies
Reply
Share
Report
D3VLPR9's avatar
N00b_Mas73r

148
August 15, 2024 12:31 AM

Read More
Hello, sorry to hear that. Better things waiting in future.


A Qq to retrospect on your experience - Why do you think you might have received a lean hire? Was the question hard or was it something else. Did recruiter specify, why the interviewer decided to give that rating. Thanks

1
Show 1 reply
Reply
Share
Report
LunaticFringe's avatar
Vicky

21
August 13, 2024 8:56 PM

Read More
What was the feedback of additional round??? Did they rejected you before finding team or after finding the team???

1
Show 3 replies
Reply
Share
Report
abdemiller's avatar
abdemiller
-32
August 16, 2024 1:42 AM

Read More
My Google interview experience was both challenging and rewarding, involving a series of technical and behavioral questions designed to assess my problem-solving skills and cultural fit. Throughout the process, I focused on showcasing my technical expertise and project management capabilities. For professionals in Qatar pursuing PMP in qatar, integrating insights from experiences like these can enhance your understanding of project management practices and improve your ability to handle complex projects. Combining interview preparation with PMP principles can significantly bolster your career prospects and project management skills in a competitive market.

1
Reply
Share
Report
vaibhav1701's avatar
Vaibhav Ransing

229
September 9, 2024 2:58 AM

Read More
Could you tell the question or data-structures on which questions were asked?
I got my interview in two weeks :)

0
Reply
Share
Report
Gupta5610's avatar
Ashish Gupta
26
August 17, 2024 2:25 AM

Read More
Hey there,


Thanks for sharing your experience. It's tough to hear about your journey, especially knowing how much effort you put in. While I can't speak directly to your specific interactions with the recruiters or interviewers, I want to acknowledge that the hiring process can sometimes be less than ideal, even at Google.


We strive for a fair and efficient process, but with the volume of candidates and the complexities involved, things can occasionally slip through the cracks or result in outcomes that feel unjust.


From my perspective as someone already working here, I can say that it's not uncommon to hear about long interview timelines or mixed feedback. It's a highly competitive environment, and the bar is set high. However, it's important to remember that rejection doesn't diminish your skills or potential. It might simply mean that it wasn't the right fit at this particular time.


I encourage you to take some time to process the experience, reflect on the feedback you received, and then channel your energy towards your next opportunity. There are many amazing companies out there, and your dedication and preparation will undoubtedly pay off.


If you're open to it, I'd be happy to connect further and offer any insights or advice I can from my experience at Google. Feel free to reach out if you'd like to chat.


Best of luck in your future endeavors!

0
Show 1 reply
Reply
Share
Report
user8708bE's avatar
Srijoni Chakroborty

93
August 15, 2024 8:46 PM

Read More
They didnt even give u L3?

https://leetcode.com/discuss/interview-question/4669794/Google-India-(New-grad)-or-Onsite-or-Merge-intervals-based-on-importance
Explore
Problems
Contest
Discuss
Interview
Store
0

avatar
Back
Google India (New grad) | Onsite | Merge intervals based on importance
3
Anonymous User
Anonymous User
February 3, 2024 1:16 PM

430 VIEWS

Given intervals sorted according to start times. An additional array is given which tells whether an interval is important or not. If important[i]=1, interval i is important.


Merge the overlapping intervals. If a point is in important as well as
unimportant interval, then that point should be important. An unimportant interval gets split into two by an important interval.


Example:
intervals = {1,3},{2,4},{5,9},{6,7},{8,13},{11,14},{13,16},{15,18}
important = 0, 0, 1, 0, 0, 1, 1, 0
Ans: {1,4},{5,9},{10,10},{11,16},{17,18}


Example 2:
intervals = {1,5},{2,11},{8,9}
important = 1, 0, 1
Ans: {1,5},{6,7},{8,9},{10,11}


Example 2:
intervals = {1,8},{2,5},{6,11},{8,9},{14,17},{17,20},{19,23},{20,28},{24,27},{26,28},{30,34},{33,36},{34,40},{38,41},{43,48},{45,50}
important = 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1
Ans: {1,1},{2,5},{6,11},{14,16},{17,28},{30,34},{35,37},{38,41},{43,44},{45,50}


I was asked this question but wasn't able to come up with a proper solutin within 45 minutes. I feel it is question involving too many if-else conditions and edge cases. Is there an elegant way to solve this?

google
india
google-onsite
onsite-interview
intervals-merge
Comments: 4
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
gaurav-x5's avatar
Gaurav Kumar

71
February 14, 2024 12:46 AM

Read More
I would use lineSweep for this problem


below is my approach


    int[][] intervals = {{1,3},{2,4},{5,9},{6,7},{8,13},{11,14},{13,16},{15,18}};
    int[] imps = {0, 0, 1, 0, 0, 1, 1, 0};

    List<int[]> res = new ArrayList<>();
    List<int[]> nImp = new ArrayList<>();

    for(int i = 0; i < intervals.length; i++) {
        if(imps[i] == 1) {
            res.add(intervals[i]);
        } else{
            nImp.add(intervals[i]);
        }
    }

    int[] impM = new int[60];

    for(int[] p : res) {
        impM[p[0]]++;
        impM[p[1] + 1]--;
    }

    

    int[] nImpM = new int[60];
    for(int[] q : nImp) {
        nImpM[q[0]]++;
        nImpM[q[1]]--;
    }

    int pi = 0;
    int npi = 0;
    int start = -1;
    for(int i = 0; i < 60; i++) {
        pi += impM[i];
        npi += nImpM[i];

        if(npi > 0 && pi == 0 && start == -1) {
            start = i;
        }
        else if(start != -1 && pi > 0) {
            res.add(new int[]{start, i-1});
            start = -1;
        }
        else if(start != -1 && pi == 0 && npi == 0)
        {       
                res.add(new int[]{start, i});
                start = -1;
        }
        
    }



    // lets merge the intervals in the subres
    Collections.sort(res, (a, b) -> a[0] - b[0]);

    LinkedList<int[]> result = new LinkedList<>();

    for(int[] r : res) {
        if(result.isEmpty()) {
            result.add(r);
        } else {
            int[] curr = r;
            if(result.get(result.size()-1)[1] >= curr[0]) {
                result.get(result.size()-1)[1] = Math.max(result.get(result.size()-1)[1], curr[1]);
            } else {
                result.add(curr);
            }
        }

    }
return result;

1
Reply
Share
Report
raghav_aditya's avatar
raghav_aditya
85
April 17, 2024 12:40 PM

Read More
My cleanest implementation of this problem took me 1 hour to get to this


SWEEP LINE


#define arr array<int,3>
#define ar array<int,2>



vector<ar> merge( vector<ar>&t , int f = 1 )
{
    vector<ar> res ;

    int a = t[0][0];
    int b = t[0][1];

    for( auto x : t )
    {
        int c = x[0];
        int d = x[1];

        if( c <= b+f )
        {
            a = min( a , c );
            b = max( b , d );
        }
        else
        {
            res.push_back({a,b});
            a = c ;
            b = d ;
        }
        // [ a , b ] || [ c , d ]
    }
    res.push_back({a,b});
    return res;
}

int32_t main() {
    
vector< ar > A = { {1,8},{2,5},{6,11},{8,9},{14,17},{17,20},{19,23},{20,28},{24,27},{26,28},{30,34},{33,36},{34,40},{38,41},{43,48},{45,50} };
vector< int > B = { 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1 };
vector< ar > I,U ;

map< int , int > mp ;

int F = 1e6; 
// this factor distinguishes wether given range is important or not during sweep, and also and we can distinguised between 
// zero range and unimportant interval range 

for( int i = 0 ; i < A.size() ; i++ )
{
    int a = A[i][0];
    int b = A[i][1];

    if(B[i])
    {
        I.push_back(A[i]); // important intervals dont changes so they are part of ans already 
        mp[a] += F ;
        mp[b+1] -= F ;
    }
    else
    {
        mp[a]++;
        mp[b+1]--;
    }
}

int st = -1 ;
int s = 0 ;

for( auto x: mp )
{
    int a = x.first ;
    int b = x.second ;

    if( s > 0 && s < F )  // here we will consider non zero sum ranges that are unimportant thats why factor is used 
    U.push_back({ st , a-1 });
    s += b ;
    st = a ;
}

I = merge(I,0); // important intervals are in exact merge  [ 1 , 1 ] [ 1 , 3 ] = [ 1 , 3 ]
U = merge(U); // unimportant intervals can merge in [ 0 1 ] [ 2 , 3 ] = [ 0 , 3 ]

vector< ar > res ;
for( auto x : I )
    res.push_back(x);

for( auto x : U )
    res.push_back(x);

sort(all(res));

for( auto x : res )
    cout<<x[0]<<" "<<x[1]<<endl;


return 0;
}  
0
Reply
Share
Report
mission_conquer's avatar
PseudoCoder

11
February 10, 2024 7:37 PM

Read More
What's the result for this?

0
Reply
Share
Report
rahulgautam297's avatar
Rahul Gautam

100
Last Edit: February 4, 2024 3:07 PM

Read More
Passes all the test cases. Code quality is poor, but someone can take it up and improve it.


// "static void main" must be defined in a public class.
public class Main {
    public static void main(String[] args) {
        // mergeIntervalsConsideringImportance(new int[][]{{1, 3, 0},{2, 4, 0},{5, 9, 1},
        //                                                 {6,7, 0},{8,13, 0},{11,14, 1},
        //                                                 {13,16, 1},{15,18, 0}});
        // System.out.println(" ");
        // mergeIntervalsConsideringImportance(new int[][]{{1,5, 1},{2,11, 0},{8,9, 1}});
        // System.out.println(" ");
        mergeIntervalsConsideringImportance(new int[][]{
            {1,8, 0},{2,5, 1},{6,11, 1},{8,9, 0},{14,17, 0},{17,20, 1},
            {19,23, 0},{20,28, 1},{24,27, 1},{26,28, 0},{30,34, 1},
            {33,36, 0},{34,40, 0},{38,41, 1},{43,48, 0},{45,50, 1}
            
        });
    }
    
    public static List<int[]> mergeIntervalsConsideringImportance(int[][] intervals) {
        ArrayList<int[]> list = new ArrayList<int[]>();
        boolean previousImportant = false;
        for (int i = 0; i < intervals.length; i++) {
            if (list.size() == 0 || list.get(list.size() - 1)[1] < intervals[i][0]) {
                list.add(new int[]{intervals[i][0], intervals[i][1]});
                previousImportant = intervals[i][2] == 1 ? true : false;
                
            // same importance of current interval and previously added
            } else if ((intervals[i][2] == 1 && previousImportant)
                    || (intervals[i][2] == 0 && !previousImportant)) {
                list.get(list.size() - 1)[1] = Math.max(list.get(list.size() - 1)[1], intervals[i][1]);
                previousImportant = intervals[i][2] == 1 ? true : false;
            // previous imp and current not
            } else if (previousImportant && intervals[i][2] == 0) {
                previousImportant = true;
                if (list.get(list.size() - 1)[1] < intervals[i][1]) {
                    list.add(new int[]{list.get(list.size() - 1)[1] + 1, intervals[i][1]});
                    previousImportant = false;
                }
            // previous not and current imp
            } else if (!previousImportant && intervals[i][2] == 1) {
                // previous' start is behind the current's start
                if (list.get(list.size() - 1)[0] < intervals[i][0]) {
                   int temp = list.get(list.size() - 1)[1];
                    list.get(list.size() - 1)[1] = intervals[i][0] - 1;
                    list.add(new int[]{intervals[i][0], intervals[i][1]});
                    previousImportant = true;
                    if (temp > intervals[i][1]) {
                        list.add(new int[]{intervals[i][1] + 1, temp});
                        previousImportant = false;
                    }   
                }
                // previous' start and the current's start are the same
                else if (list.get(list.size() - 1)[0] == intervals[i][0]) {
                    if (list.get(list.size() - 1)[1] <= intervals[i][1]) {
                        list.get(list.size() - 1)[1] = intervals[i][1]; 
                        previousImportant = true;
                    } else if (list.get(list.size() - 1)[1] > intervals[i][1]) {
                        int temp = list.get(list.size() - 1)[1];
                        list.get(list.size() - 1)[1] =  intervals[i][1] - 1;  
                        list.add(new int[]{intervals[i][0], intervals[i][1]});
                        list.add(new int[]{intervals[i][1] + 1, temp});
                        previousImportant = false;
                    }
                } else if (list.get(list.size() - 1)[0] > intervals[i][0]) {
                    list.remove(list.size() - 1);
                    previousImportant = true;
                    i--;
                }
            }
        }
        for (int[] listItem: list) {
         for (int i : listItem) System.out.print(i + ", ");
            System.out.println(" ");
        }
        return list;
    }
}

https://leetcode.com/discuss/interview-question/4994055/Google-or-Onsite-or-Allot-people-to-apartment

Google | Onsite | Allot people to apartment
8
Anonymous User
Anonymous User
April 8, 2024 9:53 PM

2.3K VIEWS

Question


Your organization has hired interns who need to relocate for the summer. You are in charge of assigning apartments to them. Each intern will get their own room. They can choose whether they prefer to share a 2+ room apartment or get a one-bedroom to themselves.
Note that they may not get what they want because the apartments vary in the number of rooms that they have.


You have the following data structures:


public class Apartment {
	public int aptNumber;
	public int numRooms;
}

public class Person {
	public String name; #Unique ID, ex: Sam
	public boolean wants_housemates
}

public Map<Integer, Collection<String>> assignApartmentsToPeople(
    Collection<Apartment> apartments, #List of Apartment
    Collection<Person> people){
	// return apartment to people  map
	}

https://leetcode.com/discuss/interview-question/5059488/Google-or-L3-or-Bangalore-or-Offer
Google | L3 | Bangalore | Offer
100
Anonymous User
Anonymous User
April 22, 2024 9:01 PM

11.1K VIEWS

General details
Education : Bachelor of Engineering in Computer Science (Tier 3)
Years of Experience : 2 years and 6 months (2021 passed out)
Current CTC : 12LPA
Date of the Offer : April 2024
Company : Google
Title/Level : Software Engineer II (L3)
Location : Bangalore
Salary Breakdown
Base : 23 LPA
Sign-on Bonus : 3 LPA
Relocation Bonus : 3 LPA
Bonus : ~3.5L (15% of Base)
Stock : $58k (38% 32% 22% 8%)
Total compensation (Base + Bonus + Stock) : ~48LPA in the 1st year
Benefits : Standard Google Perks and Benefits
Interview Process
Interviews went on for 4 months.
Had first recruiter call in Nov last week 2023
Phone Screen happened in Dec 2023
45-min coding round (Easy-Medium level)
Interviews were scheduled in Jan 2024
45-min coding round (Medium level with follow-up to Hard level)
45-min coding round (Medium level with follow-up to Hard level)
45-min coding round (Hard level)
Did this round terribly bad. Had merely solved the problem. Did not do it to the expectation. Could not solve the follow-up.
Googlyness + Leadership round
Team-Matching call happened in Feb 2024
Another Team-Matching call happened in Mar 2024
A week later got recruiter call saying that I have cleared the Hiring Committee (HC).
TC negotiation 2 days later.
Received Offer letter in April 1st week 2024
google
india
bangalore
l3
swe2
Comments: 41
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
geeky_sporty_chatterbox's avatar
geeky_sporty_chatterbox

99
April 22, 2024 10:08 PM

Read More
cp and leetcode stats?

13
Show 6 replies
Reply
Share
Report
mudit_shar's avatar
mudit sharma

63
April 24, 2024 12:24 AM

Read More
What feedback did you get in your rounds?

7
Reply
Share
Report
arpitjaswal's avatar
Arpit Jaswal

9
April 23, 2024 2:41 PM

Read More
12 ctc to 23 base, god damn! how?

6
Show 2 replies
Reply
Share
Report
rahul_lcc's avatar
rahul_lcc
398
April 25, 2024 1:09 PM

Read More
check this out - https://leetcode.com/discuss/career/5067993/Google-Act-with-urgency/

4
Reply
Share
Report
royal_risi's avatar
Ritesh Singh

15
April 23, 2024 4:53 PM

Read More
what was you tech in your previous org and what u got in google?

4
Reply
Share
Report
avidyarth12's avatar
Athithya Vidyarth
62
April 24, 2024 7:05 PM

Read More
How did you get your resume through? Can you share an anonymized version of your resume? Thanks and congrats!

2
Reply
Share
Report
Lova_Reddy's avatar
Lova Reddy

2
April 24, 2024 12:06 PM

Read More
From which topic are the questions from?

2
Reply
Share
Report
anmolgrg126's avatar
Anmol Garg

5
April 26, 2024 9:57 PM

Read More
Congratulations bro!!

1
Show 1 reply
Reply
Share
Report
rbasanti's avatar
rbasanti
188
April 24, 2024 9:54 PM

Read More
Just saw this - https://leetcode.com/discuss/career/5067993/google-act-with-urgency

1
Show 1 reply
Reply
Share
Report
arba22's avatar
A S

87
April 23, 2024 8:23 AM

Read More
Current company ?

https://leetcode.com/discuss/interview-question/5082906/Google-India-or-L5-Onsite-Interview-Question
Google India | L5 Onsite Interview Question
4
Anonymous User
Anonymous User
Last Edit: April 28, 2024 1:38 PM

771 VIEWS

Experience: Pretty disappointed with the interviewer since they were not well versed with the question and pointed out redundancy in my code which will not work and it cost me 10 mins of my interview and a lot of confusion:(.
I can't believe Google has so many incompetent interviewers who do not do their research on questions before asking them. I expect my interviewer to be well-versed of the question they ask so that they can at least understand different approaches a candidate may take.


Question & My Solution
Does anyone knows kind of same leetcode question?
Closest question I can find on leetcode: https://leetcode.com/problems/largest-rectangle-in-histogram/description/


Three players, A, B, and C play an online game. 
The game consists of a map in the shape of an RxC grid.
Each player has to capture one or more cells in the RxC grid. 
So, after the game, each cell would have the name of the player who captured it.

The winner of the game will be the player who covers the largest rectangle area in the RxC grid. 
Find the area of that largest rectangle.
  
Example:

+---+---+---+---+
| B | A | A | C |
+---+---+---+---+
| B | A | A | B |
+---+---+---+---+
| C | C | A | A |
+---+---+---+---+
| B | B | C | C |
+---+---+---+---+
  
In the above 4x4 grid, the size of the largest rectangle is 4 and the corresponding winner would be A.
  
  
  size? = 1000x1000 
  cellsFilled? = true
  there can be more players.
  no.of players as List<String>
  no more than 50 players
  
  String board[][];
  List<String> player;
  
p = no. of players
rxc = rows and column

O(p x (rxc + (r * r)))
 O(p * r*c)

+---+---+---+---+
| 0 | 1 | 1 | C |
+---+---+---+---+
| 0 | 1 | 1 | B |
+---+---+---+---+
| 0 | 0 | 1 | A |
+---+---+---+---+
| 0 | B | C | C |

  
  iterating for player A
+---+---+---+---+
| 0 | 1 | 1 | 0 |
+---+---+---+---+
| 0 | 2 | 2 | 0 |
+---+---+---+---+
| 0 | 0 | 3 | 0 |
+---+---+---+---+
| 0 | 0 | 0 | 0 |
  
    
String getWinner(List<String> players, String[][] board) {
        String winner = "";
        int max = 0;
        for(String p: players) {
            int maxRectangleForPlayer = getMaxRectangleSize(board, p);
            if(maxRectangleForPlayer > max){
                max = maxRectangleForPlayer;
                winner = p;
            }
        }

        return winner;
    }

// getMaxRectangleSize & getRectangleSize are slight modification of https://leetcode.com/problems/largest-rectangle-in-histogram/description/
    int getMaxRectangleSize(String[][] board, String player) {
        int[][] heights = new int[board.length][board[0].length];
        //come back to merge these loops
        for(int r = 0; r < board.length; r++){
            if(board[r][0].equals(player)) {
                heights[r][0] = 1;
            }
        }

        for(int r = 1; r < board.length; r++){
            for(int c = 0; c < board[0].length; c++){
                if(board[r][c].equals(player)) {
                    heights[r][c] = heights[r - 1][c] + 1;
                }
            }
        }

        //
        int max = 0;
        for(int r = 0; r < board.length; r++){
            //rectangle size if I take height as heights[r][c]
            int rectangleSize = getRectangleSize(heights, r);
            max = Math.max(max, rectangleSize);
        }
        return max;
    }

     int getRectangleSize(int[][] heights, int r) {

        int[] row = heights[r];
        int[] leftBoundary = new int[row.length];
        leftBoundary[0] = -1;
        for(int c = 1; c < row.length; c++) {
            int prev = c - 1;
            while(prev >= 0 && row[c] >= row[prev]) {
                prev = leftBoundary[prev];
            }

            leftBoundary[c] = prev;
        }
        int[] rightBoundary = new int[row.length];
        rightBoundary[rightBoundary.length - 1] = heights.length;
        for(int c = row.length - 2; c >= 0; c--) {
            int next = c + 1;
            while(next < row.length && row[c] >= row[next]) {
                next = rightBoundary[next];
            }

            rightBoundary[c] = next;
        }

        int max = 0;
        for(int c = 0; c < row.length; c++) {
            int currRectangleArea = row[c] * (rightBoundary[c] - leftBoundary[c] - 1);
            max = Math.max(max, currRectangleArea);
        }
        return max;
    }

Verdict: Rejected

google
india
Comments: 5
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
krbchd_02's avatar
krbchd_02

53
Last Edit: September 9, 2024 10:41 AM

Read More
This can be done in time complexity: O(r*c) And space complexity: O(c).
Note - we don't need to track any state related to player per se. So complexity is independent of number of player.


// Entry function. Returns largest area. Can be easily modified to also return the winning player.
int getLargesetArea(vector<vector<char>>& grid) {
      int maxR = grid.size(), maxC = grid[0].size();
      vector<int> heights(maxC);
      int largest = 1;
      for (int r = 0; r < maxR; r++) {
          int prev = 0;
          for (int c = 0; c < maxC; c++) {
              if (r == 0) { heights[c] = 1; }

              // If same player occupied position in  grid[r-1][c] then use height for grid[ r-1][c] + 1 or else just 1.
              else heights[c] = (grid[r-1][c] == grid[r][c]) ? heights[c]+1 : 1; 
              
              // Player changes after this column. so calculate max area histogram seem.
              if (c == maxC-1 || (grid[r][c+1] != grid[r][c])) {
                  largest = max(largest, findMaxAreaOfHisto(heights, prev, c));
                  prev = c+1;
              }
          }
      }
      return largest;
}

// Time Complexity - O(e-st+1)
int findMaxAreaOfHisto(vector<int>& heights, int st, int e) {
        stack<int> indexes;
        int sz = e+1;
        int maxArea = 0;
        for (int i = st;  i <= sz; i++) {
            int currHeight = (i == sz) ? -1 : heights[i];
            while (!indexes.empty() && heights[indexes.top()] >= currHeight) {
                auto top = indexes.top(); indexes.pop();
                auto topHeight = heights[top];
                int l = indexes.empty() ? st-1 : indexes.top();
                int r = i;
                maxArea = max(maxArea, (r-l-1)* topHeight);
            }
            indexes.push(i);
        }
        return maxArea;
}
7
Show 10 replies
Reply
Share
Report
sarveshchavan777's avatar
sarvesh

171
April 30, 2024 7:11 PM

Read More
Sometimes no matter how much good you're in problem solving, luck also plays role! Not all interviewers are good interviewers, anyways all the best !

2
Reply
Share
Report
rohitk2667's avatar
rohit kumar

21
Last Edit: May 15, 2024 12:36 AM

Read More
variation of https://leetcode.com/problems/maximal-rectangle/description/. Do it thrice for A,B& C

1
Reply
Share
Report
pritambiswas1699's avatar
pritambiswas1699

14
Last Edit: April 28, 2024 11:20 PM

Read More
TC- n^2
SC - n


Note: I have Replaced characters with unique integers


pair<int,int> getArea(vector<pair<int,int>> h) {
int i = 0, n = h.size(), area = 0, winner = -1, mx = 0;
while(i < n) {
int j = i;
int mn = h[i].second;
while(j < n && h[i].first == h[j].first) {
mn = min(mn, h[j].second);
j++;
}
area = mn*(j-i);
if(area > mx) {
mx = area;
winner = h[i].first;
}
i = j;
}
return {mx, winner+1};
}
pair<int,int> getWinner(vector<vector>& grid) {
int winner = -1;
int mxArea = 0;
vector<pair<int,int>> h(grid[0].size());
for(int i = 0; i < grid.size(); i++) {
for(int j = 0; j < grid[0].size(); j++) {
if(i == 0) h[j] = {grid[i][j], 1};
else {
if(grid[i][j] == grid[i-1][j]) {
h[j].second++;
} else {
h[j] = {grid[i][j], 1};
}
}
}
auto res = getArea(h);
if(mxArea < res.first) {
mxArea = res.first;
winner = res.second;
}
}


return {winner, mxArea};
}
int main() {
vector<vector> grid = {
{2,1,1,3},
{2,1,1,2},
{3,3,1,1},
{2,2,3,3}
};
auto p = getWinner(grid);
cout<<"Winner - "<<p.first<<" Area - "<<p.second<<endl;
return 0;
}

0
Show 1 reply
Reply
Share
Report
HeyWarriorKeepGoing's avatar
Warrior

69
April 28, 2024 2:43 PM

Read More
Did you had all rounds or just single one

0
Show 2 replies
Reply
Share
https://leetcode.com/discuss/interview-question/5121570/Google-or-Phone-Screen-or-Balance-Paranthesis-Post-Deletion
Google | Phone Screen | Balance Paranthesis Post Deletion
10
Anonymous User
Anonymous User
May 6, 2024 10:02 PM

1.3K VIEWS

Question


You are given a string containing only parentheses ('(' and ')') and digits (0-9). At the index of a digit, you must delete a number of parentheses to the left of the index equal to the digit's value. Return true if it is possible to balance the parenthesis of the input.

Example 1 Input: ((2)) Output: False Reason: Only possible string is unbalanced: "))"

Example 2 Input: ((((2)) Output: True Reason: Only possible string is balanced: "(())"

Example 3 Input: (()1(1)) Output: True Reason: Multiple possible strings and one is balanced: ")())", "(())", "()))".

Background: 

1.Digits should not be included in the result string, although that doesn't matter for calculating the boolean result.

2.If a digit doesn't have enough characters to the left to delete, then return false.
google
india
google-phone-interview
2024
Comments: 17
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
gonpachiro's avatar
Anoop Kumar

139
Last Edit: May 8, 2024 2:53 PM

Read More
We can use greedy approach here.
Try to delete as many close brackets as possible because if we have more close brackets than open then It's never going to be balanced. We also need to make sure that at the end open brackets = close brackets.


calculate maximum open/close brackets to delete and then delete by reducing the count of close brackets first:


toDel = digSum(str)
open = openSum(str)
close = closeSum(str)
total = open+close
maxOpDel = open-(total-toDel)/2
maxClDel = close-(total-toDel)/2
if (total-toDel)%2 == 1 return false

o = 0, c = 0
for(ch in str) {
    if(ch == '(') o++
    else if(ch == ')') c ++
    else {
        todel = ch-'0'
        cDel = min(todel, maxClDel)
        c -= cDel  // delete from close first
        maxClDel -= cDel
        todel -= cDel
        o -= todel // delete remaining from open
        maxOpDel -= todel
        if(o < 0 || maxOpDel < 0) return false
        if(o < c) return false
    }
}
return o == c
4
Show 4 replies
Reply
Share
Report
nipun753's avatar
SATYAJEET
59
Last Edit: May 7, 2024 6:26 PM

Read More
 We will be maintaining 3 states (open , closed , idx) 
Base case when idx==length return open==close else return false

otherwise 
if we encounter the digit try to reduce the number of open brackets if we have sufficient or try to decrease the closed  brackets if we have sufficient , if both condition are not satisfied return  false
#include<bits/stdc++.h>
[#define](https://leetcode.com/problems/undefined-to-null) fi first
[#define](https://leetcode.com/problems/undefined-to-null) se second
[#define](https://leetcode.com/problems/undefined-to-null) INF 100000000000000000LL
[#define](https://leetcode.com/problems/undefined-to-null) ll  long long int
const ll inf =1e9+44;
const int MAX=3e5+9;
const ll MOD= 1e9+7;
const double eps=1e-10;
double const PI=3.1415926535897931;
using namespace std;
[#include](https://leetcode.com/problems/minimum-interval-to-include-each-query) <ext/pb_ds/assoc_container.hpp>
[#include](https://leetcode.com/problems/minimum-interval-to-include-each-query) <ext/pb_ds/tree_policy.hpp>
 
typedef __gnu_pbds::tree<int, __gnu_pbds::null_type, less<int>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> ordered_set;

bool dp[400][400][400];
int vis[400][400][400];
int solve(int open  , int close , int idx , string s){

    if (idx==s.size()){
        if (open-close==0)
            return true;
        else
            return false;
    }

    if (vis[open][close][idx]!=-1)
        return dp[open][close][idx];
    vis[open][close][idx] = 1;

    if (s[idx]=='(')
        return dp[open][close][idx]  = solve(open + 1 , close , idx + 1 , s);

    else if (s[idx]==')')
        return dp[open][close][idx] = solve(open , close + 1 , idx + 1 , s);

    else{
        int limit = s[idx] -'0';
        bool ans = false;
        for (int i = 0 ; i <=limit ; i++){
            if (open - i >=0 && close -(limit - i)>=0)
                ans  = ans | solve(open - i , close - (limit - i) , idx + 1 , s);
        }
        dp[open][close][idx] = ans;
        return ans;
    }

}
int main(){
    string s;
    cin >> s;
    int bal = 0 , open = 0 , close = 0;
    int n = s.size();

    for (int i =0 ;i <=n ; i++){
        for (int j =0; j<=n;j++){
            for(int k = 0 ; k<=n; k++)
                vis[i][j][k] = -1;
        }
    }

    bool ans =  solve(0 , 0 , 0 , s);
    if (ans)
        cout <<"Yes";
    else
        cout <<"No";
    cout << endl;

}

2
Show 4 replies
Reply
Share
Report
dvictor5089's avatar
dvictor5089

71
July 5, 2024 9:07 PM

Read More
-- Python3 O(N) Time and O(N) Space --- DP, Top down with memoization and recursion


Cached State:


(i,left,right) where i = index, right = right parenthesis, left = left parenthesis.
Base Case:


i == len(string)
Recursive Steps:


(i+1,left+1,right) : when character at index i = '('
(i+1,left,right+1) : when character at index i = ')'
(i+1,left-left_rem,right - right_rem ) : try to remove all combinations of left/right parenthesis given a digit at index i. Note that this is only O(10) in the worst case so it does not effect Big O time complexity. Also we should check if the digit is > then the left + right parenthesis as per the description.
Note: there may be a greedy solution but the time complexity will also be O(N). The space complexity may be o(1) in a greedy case, but i can not think of how to solve that way if even possible. I am certain the DP way works and the efficiency is still very good.


def solution(string):
    cache = {}
    def dfs(i,left,right):
        if i == len(string):
            return True if left==right else False

        key = (i,left,right)
        if key in cache:
            return cache[key]

        ch = string[i]
        if ch == '(':
            return dfs(i+1,left+1,right)
        elif ch == ')':
            return dfs(i+1,left,right+1)

        digit = int(ch)
        if digit > right + left:
            return False

        for rem_left in range(0,digit+1):
            right_rem = digit-rem_left
            if rem_left <= left and right_rem <= right:
                if dfs(i+1,left-rem_left,right-right_rem):
                    return True
                
        cache[key] = False
        return False

    return dfs(0,0,0)
	


strings = [['((2))',False],['(()1(1))',True],['((((2))',True],['(())2',True],['((2)())',False],[ '(()())2',True],['()1()',False]] 
test = [['(()1',True]]

for string,res in strings:
    r = solution(string)
    if res == r:
        print('correct')
    else:
        print('wrong')

1
Show 1 reply
Reply
Share
Report
rohitbohra56's avatar
Rohit Bohra

50
Last Edit: May 7, 2024 8:43 PM

Read More
I think Greedy solution works
I thought of DP initally but not able to breakdown to proper subproblems
If we know we have certain characters to delete, why not start with deleting closed ones on the left side.


Based on idea of gonpachiro


    /*
    ((2)) - false
    (()1(1)) - true
    ((((2)) - true
    (())2 - true
    ((2)()) - false
    (()())2 - true
    ()1() - false
     */

    static boolean canBalanceParentheses(String s) {

        int open=0;
        int closed=0;
        int deleteCnt=0;

        for(char ch : s.toCharArray()){
            if(ch=='(') open++;
            else if(ch==')') closed++;
            else deleteCnt += ch-'0';

            // This is important to check -> Can't delete more than you got! 
            if(deleteCnt > open + closed)
            return false;
        }

        int total = open+closed;
        int final_len = total - deleteCnt;
        // final_open = final_len/2 and final_closed = final_len/2
        // int deleteOpen = Math.max(0, open - final_len/2);
        int deleteClosed = Math.max(0, closed - final_len/2); 

        int curr_open=0;
        int curr_closed=0;

        for(char ch : s.toCharArray()) {

            if(ch=='(') {
                curr_open++;
            }
            else if(ch==')') {
                curr_closed++;
            } else {
                int del = ch-'0';
                
                int maxClosedDelete = Math.min(del,Math.min(curr_closed,deleteClosed));
                curr_closed -= maxClosedDelete;
                del -= maxClosedDelete;
                deleteClosed -= maxClosedDelete;
        
                if(del>0) {
                    curr_open -= del; 
                    // curr_open will not go below zero because of the condition we kept during counting open and closed
                }
            }
        }

        return curr_open==curr_closed;
    }
Please do let me if this works
Tried on these test cases mentioned in comments

1
Show 4 replies
Reply
Share
Report
Nix106's avatar
Nix106

9
Last Edit: May 9, 2024 8:32 PM

Read More

public class Main {
    public boolean solve(String s){
        // nascent opening/closing, paired opening/closing
        int nop = 0, ncl = 0, pop = 0, pcl = 0, n = s.length();
        Stack<Character> st = new Stack<>();
        char[] ls = s.toCharArray();
        for(char c: ls){
            // if stack is empty or just opening bracket, push to stack and update variables 
            if(st.isEmpty() || c == '('){
                st.push(c);
                if(c == '(')
                    nop++;
                else
                    ncl++;
                continue;
            }
            // if closebracket, check if it can be paired and update counts accordingly
            if(c == ')'){
                if(st.top() == '('){
                    st.pop();
                    pop++;
                    pcl++;
                    nop--;
                }
                else{
                    st.push(c);
                    ncl++;
                }
            }// if ita a digit, we start decrementing counts in the following order:
            // 1) nasclent closing brackets as nothing can make them paired up in the future
            // 2) nascent opening brackets
            // 3) first a closing then opening bracket of paired up paranthesis to make sure as much as possible we maintain 
            //    pairing and opening brackets >= closing brackets
            if(c.isDigit()){
                int k = c-'0';
                // removing nascent closing brackets 
                while(k>0 && ncl>0){
                    ncl--;
                    k--;
                }
                // removing nascent opening brackets
                while(k>0 && nop>0){
                    nop--;
                    k--;
                }
                // handling paired brackets;
                // if there aren't enough brackets to delete, return false
                if(k>2*pop)
                    return false;
                if(k%2 == 0){
                    pop -= k/2;
                    pcl -= k/2;
                    k = 0;
                } else {
                    pop -= k/2 + 1;
                    pcl -= k/2 + 1;
                    nop++;
                }
            }
        }
        // if any nascent brackets remain not possible
        if(ncl != 0 || nop != 0)
            return false;
        return true;

    }
}

1
Show 3 replies
Reply
Share
Report
Algoh9's avatar
Algoh9

400
Last Edit: May 7, 2024 5:08 AM

Read More
First, go through the string and sum up all digits, Also count the number of left parentheses, and the number of right parentheses. Let's call them cumulative_sum, num_left, and num_right respectively.


If cumulative_sum is bigger than num_left + num_right, then return false, If the parity of cumulative_sum and parity of (num_left + num_right) are different then return false (you cannot make them the same at the end).


(cumulative_sum % 2 == (num_left + num_right) %2 && cumulative_sum <= num_left+num_right) need to be true


Now we can calculate the goal_number of parentheses we have to have at the end.
goal_number = (num_left + num_right - cumulative_sum) / 2


Based on goal_number you can alo calculate the number of left parentheses that you have to delete (same for the right)


num_del_left = (num_left - goal_number); num_del_right = (num_right - goal_number)


Lastly, note you can always delete the first num_del_left occurences of left parentheses.


Now go back to the string and see if cumulative_sum up to here can be deleted and maintain goal_number.


Now go through s again, and see if you have enough parentheses to delete.
If all of them validate to true, return true.


bool balanceParanthesisPostDeletion(string &s) {
    const int n = s.size();
    int num_left = 0, num_right = 0, cumulative_sum = 0;
    
    for (int ii = 0; ii < n; ++ii) {
        if (s[ii] == '(') {
            num_left += 1;
        } else if (s[ii] == ')') {
            num_right += 1;
        } else {
            cumulative_sum += s[ii] - '0';
        }
    }
    
    if (cumulative_sum % 2 != (num_left + num_right) %2 || 
        cumulative_sum > num_left+num_right) {
        return false;
    }
    
    int goal_number = (num_left + num_right - cumulative_sum) / 2;
    int num_del_left = (num_left - goal_number);
    int num_del_right = (num_right - goal_number);
    
    int num_left_post = 0;
    int num_right_post = 0;
    for (int ii = 0; ii < n; ++ii) {
        if (s[ii] == '(') {
            num_left_post++;
        } else if (s[ii] == ')') {
            num_right_post++;
        } if (isdigit(s[ii])) {
            int x = s[ii] - '0';
            while (x > 0 && num_del_left > 0 && num_left_post > 0) {
                num_left_post--;
                x--;
                num_del_left--;
            }
            while (x > 0 && num_del_right > 0 && num_right_post > 0) {
                num_right_post--;
                x--;
                num_del_right--;
            }
            if (x > 0) return false;
        }
    }
    return true;
}
This is a two-pass algorithm with O(n) time complexity. I might be missing some corner cases.


EDIT: Actually this is not O(n) because I'm doing while loop decreasing x one a time. this can be improved by deleting num_del_left -= x carefully.

1
Show 7 replies
Reply
Share
Report
codeVamos's avatar
CodeVamos

18
July 16, 2024 11:40 AM

Read More
#include <bits/stdc++.h>
using namespace std;


bool isBalance(string &s){
stack st;
int num = 0, n = s.size();


//process numbers
for(int i = 0; i < n; i++){
    if(s[i] >= '0' && s[i] <= '9'){
        num = num*10 + (s[i] - '0');
    }
    else{
        while(!st.empty() && num > 0){
            st.pop();
            num--;
        }
        if(num > 0){
            return false;
        }
        st.push(s[i]);
    }
    
}
while(!st.empty() && num > 0){
    st.pop();
    num--;
}
if(num > 0){
    return false;
}

s = "";
while(!st.empty()){
    s = s + st.top();
    st.pop();
}

reverse(s.begin(), s.end());
cout << s << endl;
n = s.size();
for(int i = 0; i < n; i++){
    if(s[i] == ')'){
        if(st.empty()){
            return false;
        }
        st.pop();
    }
    else
      st.push(s[i]);
}

return st.size() == 0;
}
int main() {
// Write C++ code here


string s = "(()1(1))";
cout << isBalance(s) << endl;

return 0;
}


(it would be simpler if we just need to count open and close ones)

0
Reply
Share
Report
srv1975's avatar
srv1975

4
May 26, 2024 12:12 PM

Read More
Hey can you please share what was your response to this question during the interview and how did the interviewer react? can you share the conversation on high level

0
Reply
Share
Report
quirell's avatar
quirell

18
Last Edit: May 10, 2024 7:48 PM

Read More
This should work, there are basically only 3 cases which are described in the comments. It took me quite a while so you need to be a genius or have solved a bunch of parentheses problems to come up with that during an interview. I'd say a dp solution should be enough to pass.


def balancedParenthesis(s):
    opened = delete = balanced = 0
    delete_left = sum(int(c) for c in s if c.isdigit())
    closing_left = sum(1 for c in s if c == ')')
    for c in s:
        if c.isdigit():
            delete += int(c)
            delete_left -= int(c)
        elif c == '(':
            opened += 1
            if opened > closing_left: # ((((2)) not enough closing brackets in the future, we need to delete an opening bracket using future deletes
                delete -= 1
                opened -= 1
        else:
            opened -= 1
            closing_left -= 1
            if opened < 0:  # )()1 not enough opened brackets in the past, we need to delete a closing bracket using future deletes
                opened = 0
                delete -= 1
            else:
                balanced += 2
        if -delete > delete_left:
            return False  # oops, not enough deletes left in the future to make up for our virtual deletes
        if delete >= 2: # (()1(1)()) we have to remove some already balanced
            balanced -= 2*(delete//2) # round down to even number
            delete = delete%2 # leftover 1
        if balanced < 0:
            return False # oops, not enough balanced parentheses to delete
    return delete == 0 and opened == 0
0
Show 1 reply
Reply
Share
Report
quirell's avatar
quirell

18
May 8, 2024 7:09 AM

Read More
Does balanced mean that the string should be a palindrome after removal ? Like is ))(())(( balanced ? Or does it need to be valid so ()()(()) this is ok.

0
Reply
Share
Report
https://leetcode.com/discuss/interview-question/5150959/Google-onsite-L3-Question

Google onsite L3 Question
16
Anonymous User
Anonymous User
Last Edit: May 14, 2024 11:05 AM

2.2K VIEWS

Question: suppose there's an Array A that contains numbers 1-N in random order. now the given array B is created by counting how many smaller number exist in front of that number for the index.
**Create array A from given array B. **


Ex : B : [ 2, 3, 0, 0, 0] (given in question)
A : [ 3, 5, 1, 2,4] ( answer )


Ex B : [ 0,0,0]
A : [ 1, 2, 3 ] (answer)


Q: B [4, 3, 2,1, 0 ]
Answer : A [5, 4, 3, 2, 1]


I was able to solve in it N^2 but couldn't optimize further.

google
india
l3
Comments: 27
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
Sharique_Ahmed's avatar
Sharique
20
Last Edit: May 13, 2024 6:06 PM

Read More
For people who don't understand how the B has these numbers [2,3,0,0,0]
[ 3, 5, 1, 2, 4]
A[0] => index 0 is 3 so to the right check for numbers smaller than 3 which are [1,2] so hence B[0] = 2
A[1] => index 1 is 5 so the smaller numbers to the right are [1,2,4] so hence B[1] = 3
A[2] => index 2 is 1 and there are no smaller number than 1 so hence B[2] = 0
A[3] => index 3 is 2 and there are no smaller number than 3 so hence B[3] = 0
A[4] => index 4 is 4 and there are no smaller number than 4 so hence B[4] = 0
so therefore ==> B = [2,3,0,0,0]
"Create array A from given array B."
So you gotta create A from the given B
Created a python implementation and nah this logic ain't mine it's MJ_Jiang one of the fellow commenter who explained the logic in C++ (Damn dude is good)


b = [2,3,0,0,0]


L = len(b)
temp_nums = [i for i in range(1,L+1)] # This will return [1,2,3,4,5]
a = [0 for i in range(L)] # This will return [0,0,0,0,0]


for i in range(L):
a[i] = temp_nums[b[i]] # So b[0] = 2 so temp_nums[2] is '3'
temp_nums.pop(b[i]) # We have to pop that value this is important


print(a)
And the time complexity is probably O(n) I guess ain't sure new to this time complexity stuff !!

18
Show 1 reply
Reply
Share
Report
nipun753's avatar
SATYAJEET
59
May 13, 2024 10:05 PM

Read More
Finding Kth order statistics using fenwick tree , O(n(logn*logn)) - Time complexity


#include<bits/stdc++.h>
[#define](https://leetcode.com/problems/undefined-to-null) fi first
[#define](https://leetcode.com/problems/undefined-to-null) se second
[#define](https://leetcode.com/problems/undefined-to-null) INF 100000000000000000LL
[#define](https://leetcode.com/problems/undefined-to-null) ll  long long int
const ll inf =1e9+44;
const int MAX=3e5+9;
const ll MOD= 1e9+7;
const double eps=1e-10;
double const PI=3.1415926535897931;
using namespace std;
[#include](https://leetcode.com/problems/minimum-interval-to-include-each-query) <ext/pb_ds/assoc_container.hpp>
[#include](https://leetcode.com/problems/minimum-interval-to-include-each-query) <ext/pb_ds/tree_policy.hpp>
 
typedef __gnu_pbds::tree<int, __gnu_pbds::null_type, less<int>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> ordered_set;


int bt[MAX];

void update(int idx , int val , int n){

    for (int i = idx ; i<=n; i+=i&-i){
        bt[i]+=val;
    }

}

int get(int idx){
    int sum  = 0;
    for (int i = idx ; i>0 ; i-=i&-i){
        sum = sum + bt[i];
    }
    return sum;
}

int findIdx(int val , int n){

    int l = 1 , r = n; 
    int ans = n;

    while(l < r){
        int mid  = (l +r)/2;

        if (get(mid)-1>=val)
            r = mid;
        else
            l = mid + 1;
    }
    /*
    for (int i = 1 ; i <=n ; i++){
        cout << get(i) - 1 << " "<<i <<" "<<val<< endl;
        if (get(i) - 1==val)
            return i;
    }
    */

    return l;

}
int main(){

    int n;
    cin >> n;

    vector < int > cnt(n + 1);

    for (int i = 1 ; i<=n ; i++)
        cin >> cnt[i];

    for (int i  = 1 ; i<=n ; i++){
        update(i , 1 , n);

    }

    vector < int > res;

    for (int i = 1 ; i<=n ; i++){
        int ele = findIdx(cnt[i] , n);
        res.push_back(ele);
        update(ele , -1 , n);
    }

    for (auto v : res)
        cout <<v<<" ";
    cout << endl;
    

}

6
Show 4 replies
Reply
Share
Report
sahil01123's avatar
Sahil Kalamkar

38
May 13, 2024 10:25 PM

Read More
This is very similar to count inversions of merge sort.
Similar to below.
https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/

5
Reply
Share
Report
rnotappl's avatar
rnotappl

802
May 14, 2024 3:06 PM

Read More
Variation of https://leetcode.com/problems/queue-reconstruction-by-height/description/. Use BIT to get O(nlogn) solution.

2
Reply
Share
Report
MJ_Jiang's avatar
MJ_Jiang
57
Last Edit: May 13, 2024 2:32 PM

Read More
Could you explain why array B is [2, 3, 0, 0, 0] if array A is [3, 5, 1, 2, 4]?


According to my understanding, array B should be [0, 1, 0, 1, 3] if array A is [3, 5, 1, 2, 4]
index 0: No smaller number exists in front of A[0], so B[0] = 0
index 1: A[0] is the only smaller number in front of A[1], so B[1] = 1
index 2: No smaller number exists in front of A[2], so B[2] = 0
index 3: A[2] is the only smaller number in front of A[3], so B[3] = 1
index 4: A[0], A[2], and A[3] are smaller numbers in front of A[4], so B[4] = 3


Please help to explain, thank you!

2
Show 2 replies
Reply
Share
Report
Adetomiwa's avatar
Adetomiwa Adesanya

118
Last Edit: May 14, 2024 1:17 PM

Read More
I believe this problem can be solved more efficiently using an ordered set, achieving a time complexity of O(n log n).


Here's the approach:


Iterate through array A from right to left.
For each element A[i], find its upper_bound in the ordered set. Since the elements are distinct, this gives us the position of the next greater element.
Store this position in the appropriate index of array B.
Insert A[i] into the ordered set before moving to the next element.

https://leetcode.com/discuss/interview-question/5155597/Google-Phone-Screen-2024-APAC-India
Google Phone Screen - 2024 - APAC - India
3
Anonymous User
Anonymous User
Last Edit: May 22, 2024 4:54 PM

659 VIEWS

I had my Google Phone screen interview last week , I do not know that will be the outcome .


Problem 1:
You have a list of time intervals representing activities, each with a start and end time. Given that these activities can overlap, you need to determine the combined time intervals during which any activity occurs. Write a function that takes this list of time intervals and returns the merged intervals of activity.


Problem 2:
Additionally, you have an array of restricted time intervals. If any activity overlaps with these restricted intervals, that activity is canceled, freeing up that time. Write a function that takes both the list of activity intervals and the restricted intervals, and returns the merged intervals of activity considering these restrictions.


Suffering from anxiety regarding the result , I need to work on more DSA Skills , now I am in a confused state of mind , weather do they recruit me or not , will I pass the Phone Screen Round , If I pass , will I be able to clear 3 other DSA rounds .


I mostly consider it as a reject , because Interviewer was not confident in body language .


I need a lot of energy , practise , intelligence and prayers to pass further rounds if I get selected , If not I need a tons of courage to work more to achieve more . I see that I lack both .


~MR.D


Edit 1 :
https://leetcode.com/discuss/interview-experience/4985300/Microsoft-Interview-Experience-SDE-2
https://leetcode.com/discuss/interview-question/4669868/Interview-Experiences-Google-Amazon-Paypal-Walmart-Sprinkler-MMT-Fresh-Works-I-PAC
https://leetcode.com/discuss/interview-experience/4181782/Google-phone-screen-L3-ghosted

google
india
faang interview
google coding challenge
mr.d
Comments: 5
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
fugajayku's avatar
fugajayku

64
Last Edit: May 14, 2024 2:21 PM

Read More
problem1
TC: O(nlogn)
SC: O(n)


vector < vector < int >> getMergedIntervals(vector < vector < int >> & intervals) {

  int n = intervals.size();

  //O(n log n)
  sort(intervals.begin(), intervals.end(), [](vector < int > & a, vector < int > & b) {
    return a[0] < b[0];
  });

  vector < vector < int >> mergedIntervals;

  //O(n)
  for (int idx = 0; idx < n; idx++) {
    if (mergedIntervals.empty() || intervals[idx][0] > mergedIntervals.back()[1]) {
      mergedIntervals.push_back(intervals[idx]);
    } else {
      vector < int > lastInterval = mergedIntervals.back();
      mergedIntervals.pop_back();
      mergedIntervals.push_back({
        lastInterval[0],
        max(lastInterval[1], intervals[idx][1])
      });
    }
  }

  retrun mergedIntervals;
}
Problem2
TC: O(nlogn)
SC: O(n)


vector < vector < int >> getMergedIntervals(vector < vector < int >> & intervals, vector < vector < int >> & restrictedIntervals) {

  int n = intervals.size();

  int totalRestrictedIntervals = restrictedIntervals.size();

  vector < int > startTimeRestricted, endTimeRestricted;

  for (auto interval: restrictedIntervals) {
    startTimeRestricted.push_back(interval[0]);
    endTimeRestricted.push_back(interval[1]);
  }

  sort(startTimeRestricted.begin(), startTimeRestricted.end());
  sort(endTimeRestricted.begin(), endTimeRestricted.end());

  //O(n log n)
  sort(intervals.begin(), intervals.end(), [](vector < int > & a, vector < int > & b) {
    return a[0] < b[0];
  });

  vector < vector < int >> mergedIntervals;

  //O(n)
  for (int idx = 0; idx < n; idx++) {

    //check if current interval is colliding with any restricted interval

    //O(logn)
    int numberOfRestrictedAfterCurrent = totalRestrictedIntervals - (upper_bound(startTimeRestricted.begin(), startTimeRestricted.end(), intervals[idx][1]) - startTimeRestricted.begin());

    //O(logn)
    int numberOfRestrictedBeforeCurrent = lower_bound(endTimeRestricted.begin(), endTimeRestricted.end(), intervals[idx][0]) - endTimeRestricted.begin();

    //no collision
    if (numberOfRestrictedAfterCurrent + numberOfRestrictedBeforeCurrent == totalRestrictedIntervals) {
      if (mergedIntervals.empty() || intervals[idx][0] > mergedIntervals.back()[1]) {
        mergedIntervals.push_back(intervals[idx]);
      } else {
        vector < int > lastInterval = mergedIntervals.back();
        mergedIntervals.pop_back();
        mergedIntervals.push_back({
          lastInterval[0],
          max(lastInterval[1], intervals[idx][1])
        });
      }
    }
  }

  retrun mergedIntervals;
}
6
Reply
Share
Report
codedoctor's avatar
Saurabh Saxena

174
May 19, 2024 9:08 AM

Read More
def merge_intervals(intervals):
    if not intervals:
        return []

    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    
    for current in intervals[1:]:
        previous = merged[-1]
        if current[0] <= previous[1]: # overlap
            previous[1] = max(previous[1], current[1])
        else:
            merged.append(current)
    
    return merged

def merge_intervals_with_restrictions(intervals, restrictions):
    merged_intervals = merge_intervals(intervals)
    restricted_intervals = merge_intervals(restrictions)
    merged_with_restrictions = []
    
    for interval in merged_intervals:
        valid = True
        for restriction in restricted_intervals:
            if interval[0] < restriction[1] and interval[1] > restriction[0]: # overlap
                valid = False
                break
        if valid:
            merged_with_restrictions.append(interval)
    
    return merged_with_restrictions

# Example usage:
activities = [(1, 3), (2, 4), (5, 7), (6, 8)]
restrictions = [(2, 5)]
print("Merged intervals of activities:", merge_intervals(activities))
print("Merged intervals of activities with restrictions:", merge_intervals_with_restrictions(activities, restrictions))
2
Reply
Share
Report
dhruvp16011's avatar
LC_D_P

115
May 14, 2024 1:59 PM

Read More
Problem - 1
Its basically Merge intervals maybe with some twists


Problem - 2
treemap for restrcited activity check for overlap if not then same process as problem 1

1
Reply
Share
Report
shubhamshrishrimal's avatar
shubham jain

25
May 14, 2024 7:03 PM

Read More
For problem2
we can modify interval1 and restricted interval to add indicator of type of interval, i.e. , 0/1
We can merge both interval and then sort
then this becomes simple variation of merge interval. Just one change is -> if current interval overlaps with res-last-interval and any of them is of type
Case 1: cur interval overlap with prev interval which if of type1 -> do nothing.
Case 2: cur interval overlap with prev interval and cur interval is type 1 -> remove prev interval and insert cur interval
Case 3: both interval are of same type : merge them
Finally return intervals of type 0


origin interval [[2,4], [4,6], [6, 9]] restricted interval: [[1,2], [4,5]]


Final interval -> [ [1,3, 1], [2,4, 0] , [4,6, 0], [4,5, 1], [6,9, 0] ]
res = [1,3,1] [4,5,1] [6, 9,0] - > res = [[6,9]]

0
Reply
Share
Report
pradhev's avatar
Pradheep Kumar V

0
May 14, 2024 2:08 PM

Read More
did you answer the problem 2? if answered, you don't need to worry about the result. keep prepping for onsite.

0
Reply
Share
Report
https://leetcode.com/discuss/interview-question/5542894/Google-India-oror-OA

Google India || OA
0
Anonymous User
Anonymous User
July 27, 2024 2:40 PM

262 VIEWS

You are given a binary string str of length n.
A binary string consists of only '0' and '1'. 
For each subsequence(excluding empty) for string str, you need to find its decimal representation.
Print the number of distinct decimal values of the subsequences. 
Since, the answer can be very large, print it modulo (10^9 + 7).

Input - 
Line 1 contains number of test cases T.
Line 2 contains n - length of binary string str
Line 3 contains str - the binary string

Constraints -
n <= 2*(10^5)
Can someone help me with this, tell me the algorithm.

hard
google
india
oa
Comments: 1
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
superlaaft's avatar
superlaaft

31
July 27, 2024 5:24 PM

Read More
It is like https://leetcode.com/problems/distinct-subsequences-ii
only thing that u have to take care is to ignore the leading zeros in first. If string is "000010110", consider string as just "10110" and apply the distinct subsequence algorithm which runs in O(N) time and space. At last, return dp[n]+(isZeroPresent).
https://leetcode.com/discuss/interview-question/5543078/Google-India-oror-OA-oror-SWE-oror-New-Grad-2025

Google India || OA || SWE || New Grad 2025
2
Anonymous User
Anonymous User
July 27, 2024 3:24 PM

363 VIEWS

You are given an undirected tree with N nodes. 
Each node of the tree is assigned to a value.
You are required to divide the nodes into as little groups as possible, such that no two nodes in the group are adjacent to each other.
Consider a group G. Let us consider a pair (u,v) from the group.
The value of pair (u,v) is given as |A[u] - A[v]| where A[x] is the value assigned to node x(1<=x<=n).
The cost of group G is defined as the maximum sum you can get by pairing up the nodes at G.
Each node can be used only once to make a pair.
It is possible for some nodes in G to be unpaired.
Find the sum of costs of all possible that can be made for the given tree.

Input ->
First line containg T - number of test case
First line of each test case containing N - number of nodes.
Second line of each test case containing N space separated integers denoting array A[]
Next N-1 lines contain U and V denoting an edge between the nodes U and V.

Constraint ->
1<=T<=10
1<=N<=1e5
1<=A[i]<=1e9
1<=U,V<=N

Sample input ->
1
5
12 17 14 13 16
1 2
1 3
1 5
2 4

Sample output -> 
4

Explanation ->
Group 1:Nodes 1 and 4 can be grouped together -> |12-13| = 1
Group 2:Nodes 2, 3 and 5 can be grouped together. Pairing node 2 and 3 we get |2-3|=1,  Pairing node 3 and 5 we get |14-16|=2, Pairing node 2 and 5 we get |17-16|=1
cost(G1) + cost(G2) = 1+3 = 4
graph
hard
google
tree
india
oa
Comments: 3
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
wsilent345's avatar
wsilent345
42
July 27, 2024 5:57 PM

Read More
How did you apply ?

1
Show 2 replies
Reply
Share
Report
Deepti_iit's avatar
Deepti Gupta

1
October 1, 2024 11:29 PM

Read More
i think explanation of Group 2 is incorrect here
Explanation ->
Group 1:Nodes 1 and 4 can be grouped together -> |12-13| = 1
Group 2:Nodes 2, 3 and 5 can be grouped together. Pairing node 3 and 5 we get |14-16|=2, Pairing node 2 and 5 we get |17-16|=1, so the cost of Group 2 is 2+1=3
cost(G1) + cost(G2) = 1+3 = 4

0
Reply
Share
Report
sri_datta's avatar
Sri Datta Budaraju

185
July 31, 2024 2:57 AM

Read More
Wow, this is pretty hard. For a new grad this hard question are not needed i guess, but when you are new grad and DSA courses and in full prep it is better time than when you have a job. I hope you get an awesome job. Good luck. thanks for sharing

https://leetcode.com/discuss/interview-question/2340908/Solve-recent-MAANG-Online-Assessment-question.

Explore
Problems
Contest
Discuss
Interview
Store
0

avatar
Back
Solve recent MAANG Online Assessment question.
5
Anonymous User
Anonymous User
Last Edit: July 27, 2022 5:35 PM

766 VIEWS

Alice is a smart student who is very good at math. She is attending a math class. In this class, the teacher is teaching the students how to use a calculator. The teacher will tell an integer to all of the students, and the students must type that exact number into their calculators. If someone fails to type the number, he or she will be punished for failing such an easy task!


Unfortunately, at the beginning of the class, Alice finds that her calculator is broken! She finds that some of the number buttons are totally broken, and only the "multiply" and "equals" operator buttons are available to use. So she can only use these buttons to get the number quickly.


For instance, the teacher may say the number "60", while Alice's calculator can only type "1", "2" and "5". She could push the following buttons:


Button "15" (2 clicks)


Button "multiply" (1 click)


Button "2" (1 click)


Button "multiply" (1 click)


Button "2" (1 click)


Button "equals" (1 click)


This method requires 7 button clicks. However, if Alice uses "12*5=", only 5 clicks are needed. Of course Alice wants to get the integer as fast as possbile, so she wants to minimize the number of button clicks. Your task is to help her find a way to get the required number quickly.


Input


The first line of the input gives a number T, the number of integers the teacher says. T test cases follow.


Each case contains two lines. The first line contains ten numbers each of which is only 0 or 1. the ith number (starting from 0) is "1" if the number i can be clicked, or "0" if it is broken. The second line contains only one number X, the integer the teacher tells everyone.


Output


For each test case, output one line containing "Case #x: y", where x is the test case number (starting from 1) and y is the minimum number of button clicks needed, or "Impossible" if it is not possible to produce the number.


SAMPLE


INPUT


3


0 1 1 0 0 1 0 0 0 0


60


1 1 1 1 1 1 1 1 1 1


128


0 1 0 1 0 1 0 1 0 1


128


OUTPUT


Case #1: 5


Case #2: 4


Case #3: Impossible


CONSTRAINTS


1 <= T <= 100


1 <= X <= 10^6

google
india
google-oa
google-sde
Comments: 2
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
leetcode_dafu's avatar
leetcode_dafu

2616
July 28, 2022 1:56 AM

Read More
digits=[1,2,5]

@cache
def t(num,eq):
    if not set(str(num))-set(map(str,digits)):     
        return len(str(num))+eq
   
    dp,ret=[0],float(‘inf’)
    for i in dp:
       for j in digits:
             k=i*10+j
             if k>1 and num%k==0:
                ret=min(ret,len(str(k))+1+t(num//k,1))     
             if k**2<=num:
                dp+=[k]
    return ret
  return t(1000000,0) 
0
Reply
Share
Report
zerojude's avatar
aditya raghav

509
July 27, 2022 10:14 PM

Read More
Don't post the solution to this problem publically this question is from an ongoing off-campus drive of Disney + Hotstar,
I hate it when people try to cheat like this

https://leetcode.com/discuss/interview-question/2557189/Google-or-SWE-Intern-(Winter)or-India-or-Sep-2022-or-Rejected
Google | SWE Intern (Winter)| India | Sep 2022 | Rejected
5
Anonymous User
Anonymous User
Last Edit: September 10, 2022 4:46 PM

644 VIEWS

Status: Undergrad, B.Tech, CSE
Position: SWE Intern (Winter 2023)
Location: Bangalore/Hyderabad
Date: September 2-4, 2022
2 X 45 mins Technical Interview (Based strictly on Problem Solving with DSA)


Technical Interview 1: [LEVEL : MEDIUM]
Algorithm question -
[WARMUP]


You are given a series of intervals in the form of list of lists, and a target x. Your task is to return True if x lies in the interval, or False otherwise. 

Testcase 1:
Input:
[[1-3],[4-7],[9-21]], x = 15

Output:
True 

Explanation: 15 exists in interval [9-21]. 

[MAIN QUESTION]
Follow up after explaining the warmup question''s approach -
Instead of a single target x, you will be given a stream of queries (q), where
each query will have a target x. Return a boolean array ({True,False,True,...])
for given queries,True if they exist in one/more intervals, and False, if they do 
not exist in any of the given interval. 

Testcase 2:
Input:
[[1-3],[4-7],[9-21]], queries = [4,6,8,10,15]

Output - [True,True,False,True,True]

Explanation - 
Every query except 8, exists in the given intervals.
He clarified these after I asked some questions -
1. Intervals are non overlapping.
2. They are sorted.
3. You can assume there will be no negative intervals.


Required Time Complexity - O(log N)
Required Space Complexity - O(1)


Final follow up - What if the intervals were overlapping?


Feedback gained : Positive. I explained brute, better and optimal approaches. He expected a binary search approach. At the end he asked me to practice coding in time bounded environment for fast paced coding.


P.S - Interviewer was very chill and helpful person. Gave hints. Focused more on problem solving approaches than code.


Technical Interview 2: [LEVEL: HARD]


Given two lists of integers, A and B, list A represents the daily profit of working at CityA 
and list B represents the daily profit of working at CityB. You are a salesman and you have to
switch between cityA and cityB due to various client requirements. When you switch from cityA 
to cityB, you have to travel. The day you travel (T), cannot be considered as a working day,
and hence your net profit on travel days are 0. 
Your task is to output a schedule which includes working as well as travelling such that your profit is maximized. 

The only example testcase he provided, is given below-
Testcase1: 
Input:
A[] = [23,4,5,2], B[] = [20,1,10,100]

Output:
"ATBB"

Explanation -
An optimal schedule will be-
Day 1 : Work at cityA -> profit is 23
Day 2 : Travel -> profit is 0
Day 3: Work at cityB -> profit is 10
Day 4: Work at cityB -> profit is 100

After some questions from my side, he clarified these -


The length of array A and array B will always be equal. Each index of array A/B is treated as day(i), and the value at day(i) is your profit for that day (if you worked). If you travelled at day(i), profit for that day won't be added to your net profit.
You can work in a city for more than 1 day. But, travelling is mandatory. You cannot work in only city A or city B.
There will be no dreaded zeroes in any of the array values.
After much struggle, I figured out it's recursion type problem. I said that, he agreed and asked me to show a memoized dynamic programming solution.


Required Time Complexity - O(N)
Required Space Complexity - O(N)


I could not solve this, and required a lot of hints. I solved a good amount of dp problems, but never came accross this kindof problem, hence I was stuck.
In the last few minutes, after taking some help, I was just able to code 3 lines, that too with awfully broken code.


Feedback gained : He asked me to solve hard tagged dynamic programming problems from leetcode.


P.S - Interviewer didn't mesh well. He was not at all helpful, neither gave a hint. He kept pin drop silence even after watching me struggle. In the final minutes, he spoke to explain the approach. He himself struggled to explain it properly though. I couldn't undertsand what he meant.


Ik I have to work a lot on myself too, but I am very straight to this point that, if he tried to be helpful, I could have solved it.
A short piece of advice would be to NOT assume by default that all Google/ or rather all interviewers are always helpful, and prepare in such a way that minimal help is needed from interviewers.


Bad day. Happens. NVM.


I request the brilliant coders and problem solvers present in the LeetCode community to provide meaningful approaches and/or solutions to the problems I stated. It will be very helpful to me and others.


A humble request - I would be highly thankful if somebody puts their effort to present a Java/Python solution. I really struggle with CPP codes.


Thanks in advance! 

Happy LeetCoding!
google
interview question
india
interview experience
internship
phone screening
Comments: 5
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
BawliGand's avatar
Chaand Taro
101
November 11, 2022 1:05 PM

Read More
Hey after how many days of interview did you got your result?

1
Reply
Share
Report
blackbriar's avatar
Nilesh

11
December 2, 2022 5:04 PM

Read More
c++ solution : https://leetcode.com/playground/A8CbeYst

0
Reply
Share
Report
ashu_3916's avatar
ashish dangi
495
Last Edit: September 26, 2022 1:09 AM

Read More
for Q1, if intervals lies in range 10^6 , then we can do a line sweep and then answer each query in O(1) time .


for large values , we can merge the intervals , and perform lower bound on starting points of the intervals and find the interval if exists. O(logn)

0
Reply
Share
Report
agarwal_67's avatar
agarwal_67
1
September 12, 2022 8:55 PM

Read More
how to do 1st ques if the intervals were overlapping?

0
Show 1 reply
Reply
Share
Report
gonpachiro's avatar
Anoop Kumar

139
September 12, 2022 6:09 PM

Read More
In first question:
Required Time Complexity - O(log N)
is this time complexity for each query(then total = O(qlogN)), or for all query together
Also, are all the queries sorted?

0
Show 3 replies
Reply
Share
Report

https://leetcode.com/discuss/interview-question/2680247/MAANG-or-OA

MAANG | OA
0
jainsiddharth99's avatar
Siddharth Jain

23
Last Edit: October 9, 2022 1:33 PM

370 VIEWS

Question :
Jimmy owns a garden in which he has planted N trees in a row. After a few years, the trees have grown up and now they have different heights.
Jimmy pays much attention to the aesthetics of his garden. He finds his trees aesthetically pleasing if they alternately increase and decrease in height (..., shorter, taller, shorter, taller, ...).
These are examples of aesthetically pleasing trees:
After Image
These are examples of trees that are aesthetically pleasing:
After Image 2
Note that two adjacent trees cannot have equal heights. It may turn out that some trees have to be cut out, in order to keep the remaining trees aesthetically pleasing. However, there is a legal restriction that allows a gardener to cut out at most one tree in his possession. In how many ways can Jimmy cut out exactly one tree, so that the remaining ones are aesthetically pleasing?
Write a function:
class Solution { public int solution(int[] A); }
that, given an array A consisting of N integers, where A[K] denotes the height of the K-th tree, returns the number of ways of cutting out one tree, so that the remaining trees are aesthetically pleasing. If it is not possible to achieve the desired result, your function should return −1. If the trees are already aesthetically pleasing without any removal, your function should return 0.
Examples:


Given A = [3, 4, 5, 3, 7] your function should return 3:
You can remove A[0] so the sequence becomes [4, 5, 3, 7].
You can remove A[1] so the sequence becomes [3, 5, 3, 7].
You can remove A[2] so the sequence becomes [3, 4, 3, 7].
Given A = [1, 2, 3, 4] your function should return −1, since there is no single tree that Jimmy can cut out that would leave the rest of the trees looking aesthetically pleasing.
Given A = [1, 3, 1, 2] your function should return 0, since the trees are already aesthetically pleasing and no removal is needed.
Assume that:
N is an integer within the range [4..200];
each element of array A is an integer within the range [1..1,000]
Solution : 
def solution(A):
    res = 0
    if cutting(A):
        return 0

    for i in range(len(A)):
        s = sub(A, 0, len(A)-1)
        s = s[:i]+s[i+1:]
        if cutting(s):
            res += 1
    return res if res != 0 else -1


def sub(A, start, end):
    lt = []
    for i in range(start, end+1):
        lt.append(A[i])
    return lt


def cutting(A):
    for i in range(1, len(A)-1):
        if (A[i-1] <= A[i] and A[i] <= A[i+1]) or (A[i-1] >= A[i] and A[i] >= A[i+1]):
            return False
    return True
python
google
netflix
india
meta
maang
amazon
apple
https://leetcode.com/discuss/interview-question/2771105/Googleor-telephonic-round
Google| telephonic round
9
Anonymous User
Anonymous User
November 2, 2022 10:24 PM

1.7K VIEWS

recently, one of my friend gave google interview and the question goes


Given a hierarchy of managers, as a tree, with every mode value is the salary of the manager, find out the number of managers underpaid.
How are they underpaid? if salary of manager is lesser than the average of its children nodes salary.


I understand the problem, just dont know how to optimally aproach it... any solutions please?

google
india
telephonic round
Comments: 9
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
feldlime's avatar
Igor Belkov

10
Last Edit: November 5, 2022 1:56 PM

Read More
As @ricky_dubey mentioned it is an open question to ask if you need to count underpaid managers up the tree.


example

4
Show 1 reply
Reply
Share
Report
RohanPrakash's avatar
Rohan Prakash
5572
November 4, 2022 8:33 AM

Read More
Looks like simple bfs problem,
(Assuming you can have multiple child nodes for a node)
in bfs traversal, for a particular node, find all child node, count and sum them up, check if avg is lower than currNode, then ansCount++

5
Show 1 reply
Reply
Share
Report
lei_zhang_00's avatar
Lei Zhang

5
November 27, 2022 11:29 PM

Read More
public class FindUnderpaidManager {


private static int numOfUnderpaidManagers = 0;

public static void main(String[] args) {
	NaryNode left = new NaryNode(10);
	left.children = Arrays.asList(new NaryNode(11), new NaryNode(12), new NaryNode(13));

	NaryNode right = new NaryNode(3);
	right.children = Arrays.asList(new NaryNode(15), new NaryNode(8));

	NaryNode root = new NaryNode(20);
	root.children = Arrays.asList(left, right);

	System.out.println(find(root));
}

private static int find(NaryNode root) {
	dfsHeper(root);
	return numOfUnderpaidManagers;
}

private static int dfsHeper(NaryNode root) {
	if (root == null)
		return 0;

	List<NaryNode> children = root.children;
	int sum = 0, totalEmployees = 0;
	if (children != null) {
		for (NaryNode child : children) {
			if (child != null) {
				sum += dfsHeper(child);
				totalEmployees++;
			}
		}
	}

	if (totalEmployees > 0 && root.val < (sum / totalEmployees))
		numOfUnderpaidManagers++;

	return root.val;
}
}

2
Reply
Share
Report
siddharth_13's avatar
Siddharth Yadav

62
November 3, 2022 11:46 AM

Read More
Simple bottom-up DFS, will need extra space for getting average of children.

1
Reply
Share
Report
k_aman02's avatar
Aman Kumar

10
November 2, 2022 11:18 PM

Read More
PostOrder Traversal on tree could solve the problem. Though the catch here is that the given tree is directed acyclic graph, and given number of employees sum at any point might overflow.
To resolve this you can use different techniques, like instead summing all children use hashmap / any sorted data structure and then calculate the average pay, in this way you might need not to sum the salaries of all employees under that manager preventing overflow.
Or, you can also look into use cases from modulo function, or could look into finding others ways as well to find the average of pay sum.


I think question is more towards optimizing the memory instead of time complexity, since either ways we need to traverse all employees under a single manager giving us time complexity of O(numberOfEmployeeInOrg).
Also you as a candidate should ask about a scenario where a single employee is say underpaid, will it effect the immediate manager.

1
Reply
Share
Report
CootSaiyan's avatar
kwuutSaiyan

8
Last Edit: February 13, 2024 9:01 PM

Read More
self.ans = 0
def findAverageTree(root):
       if not root:
           return 0,0
       rootLeftSum,rootLeftNo = findAverageTree(root.left)
       rootRightSum,rootRightNo = findAverageTree(root.right)
       
       if not root.left and not root.right:
           return root.val,1       
       
       if root.val < (rootLeftSum+rootRightSum)/(rootLeftNo+rootRightNo):
             self.ans+=1
       return rootLeftSum+rootRightSum+root.val,rootLeftNo+rootRightNo+1

if the data structure is given a graph, do similar recursion but with multiple children nodes

0
Reply
Share
Report
user1150qk's avatar
user1150qk
0
January 26, 2023 3:15 PM

Read More
static int countUnderpaidRec(NTreeNode Tree, int count) {
if(Tree == null) {
return count;
}
int sum = 0 ;
if(Tree.children.size() > 0 ) {
for(NTreeNode child : Tree.children) {
sum = sum + child.val;
}


    		double avg = (double)sum / Tree.children.size();
    		
    		if(avg > Tree.val) {
    			count++;
    		}
    	}
    	for(NTreeNode child : Tree.children) {
    		countUnderpaidRec(child,count);
    	}     
    	return count;
    }
0
Reply
Share
Report
amany5642's avatar
Amany Mounes

18
Last Edit: November 21, 2022 4:48 AM

Read More
def find(root):
    count = 0
    def helper(root):
        nonlocal count
        if not root:
            return 0

        curSum = number_of_children = 0
        for child in root.children:
            curSum += helper(child)
            number_of_children += 1

        if number_of_children and (curSum // number_of_children) > root.val:
            count += 1

        return root.val

    helper(root)
    return count
    
0
Reply
Share
Report
nidran's avatar
nidran

409
November 13, 2022 7:34 PM

Read More
Something like this - https://leetcode.com/playground/H6g5JrD2

0
Show 1 reply
Reply
Share
Report

https://leetcode.com/discuss/interview-question/2312095/Google-Technical-round

Google Technical round
1
iinaimaf's avatar
Naima Farooqi
9
July 21, 2022 1:22 PM

250 VIEWS

Given a shelf, its shelf width and an array of parcels and its frequency. The array of parcels contains the width of parcels and the frequency array contains the number of times a parcel can be used. You need to maximize the shelf utilization. You can use the parcels from the parcel array to fill up the shelf. One parcel can be used Frequency[i] number of times.


example 1 - 
Shelf Width = 10
Parcel length array = [3,5,7]
frequency = [1,2,2]

Ans - 
10 (How? [3, 7])
10 (How? [5,5])


example 2 - 
Shelf Width = 10
Parcel length array = [3,5,7]
frequency = [3,1,0]

Ans - 
9 (How? [3, 3,3])
google
india
technical-screening
Comments: 1
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
aradhya_12's avatar
Aradhya Tripathi

5
July 21, 2022 8:03 PM

R
ead More
it's looks coin exchange dp problem with variation of finite no. of coins. I guess here we would have to take three states in acc N x Limit x Width
https://leetcode.com/discuss/interview-question/2291394/Google-SWE-Online-Assessment-Questions-I-could-not-solve
Google SWE Online Assessment Questions I could not solve
4
Anonymous User
Anonymous User
Last Edit: July 16, 2022 11:29 PM

734 VIEWS

Q1. Count Pairs
Given 2 integer arrays, a and b and 2 integers c and d, find the pairs of i,j such that
(ai - aj+c) <= (bi - bj + d), where i<j.
Sample Test Case:
Given:
n = 5
c = 3
d = 2
Array a = [9,4,2,3,6]
Array b = [1,4,3,1,2]
Approach:
5 pairs of (i,j): {(2,4), (2,5), (4,5), (3,5),(3,4)} satisfying the given inequality. Therefore, the answer is 5.


My approach:
Brute force, O(N^2):


for(int i=0;i<n-1;i++){
    for(int j=i+1;j<n;j++){
	    if(ai-aj+c <= bi-bj+d)
		   count++;
This approach, as expected gave TLE. I tried reducing the time complexity by creating a difference array, d = a-b, and using binary search but we cannot sort this array as i<j is given. How to solve this in less than O(N^2) ?


Q2.
##q2


//Good path
    int dfs(int u, Map<Integer, Integer> map) {
        map.merge(u, 1, Integer::sum);
        if(map.size() > 2) return 0;
        int cnt = 0;
        if((map.size() == 1) || (map.size() == 2 && 2*map.get(u) == map.values().stream().mapToInt(v-> v).sum())) cnt += 1;
        for(int v : G[u]) cnt += dfs(v, map);
        map.merge(u, -1, Integer::sum);
        map.remove(u, 0);
        return cnt;
    }
0
Reply
Share
Report
leetcode_dafu's avatar
leetcode_dafu

2616
Last Edit: July 17, 2022 2:21 AM

Read More
Q2 do some modification to https://leetcode.com/discuss/interview-question/2271243/good-path-google-oa-2022/1484647
If max == length, it's good.
If max == length/2 and num unique elements == 2, it's good, because the count of the other element must also be length/2.
Otherwise, it's not a good path.

0
Show 1 reply
Reply
Share
Report
leetcode_dafu's avatar
leetcode_dafu

2616
Last Edit: July 17, 2022 7:53 PM

Read More
Q1 O(nlogn) merge sort (https://leetcode.com/discuss/interview-question/2258685/Google-OA) or use tree-based sortededlist


from sortedcontainers import SortedList
stack=SortedList()
ct=0
for i,j in zip(a,b):
    val=i-j
    ct+=stack.bisect_right(val-c+d)
    stack.add(val)
return ct
0
Show 2 replies
Reply
Share
Report
A_S_'s avatar
Ani
1589
July 17, 2022 12:48 AM

Read More
The questions are really tough !!

https://leetcode.com/discuss/interview-question/2260088/Special-Paths-or-Google-OA-or-July-2022-or-Graph
Explore
Problems
Contest
Discuss
Interview
Store
0

avatar
Back
Special Paths | Google OA | July 2022 | Graph
40
Anonymous User
Anonymous User
Last Edit: July 11, 2022 10:34 AM

7.3K VIEWS

You are given the following:


A tree with N nodes
An array A denoting the value of each node
A path is called special path if the following conditions are satisfied:


All nodes in the path are traversed exactly once.
The value of starting and terminating node in the path is same and startnode != terminating node
The values of any node in the path are not greater than the value of starting node.
Task:
Count the no. of special paths in the tree. (Two paths are different if they contain at least one different node.)


Example:
N = 5
edges = [(1,2), (1,3), (3,4), (3,5)]
A = [2,3,1,2,3]


image


Output:
2


Explanation:
path 1: 1(2)->3(1)->4(2)
path 2: 2(3)->1(2)->3(1)->5(3)


Constraints
1<= T <= 10
2 <= N <= 10^5
1<=Ai <= 10^9


I tried brute force by applying DFS at every node. I got TLE.
Any suggestions or approach is appreciated :)

graph
google
tree
india
oa
online assesment
Comments: 12
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
leetcode_dafu's avatar
leetcode_dafu

2616
Last Edit: September 25, 2022 9:17 AM

Read More
Sort values O(nlogn)+Union find O(n). If there are n nodes with the max value of a tree, we will have n*(n-1)//2 unique paths among them. To form other paths, we can remove all max nodes because the other nodes are smaller. Removing max nodes will result in new sub-trees, we can count new paths with max nodes in each sub_tree recursively. However, this is O(N^2).


To save time, we do the above backwards, which is O(n). With no sub_trees at first, we sequentially union nodes from low to high to form bigger sub-trees until having the full tree. When connect a node to a sub-tree, if node value = the sub_tree’s max value, we get a new path


connect=collections.defaultdict(set)      # record the neighbors for every node
for i,j in edges:
    connect[i].add(j)
    connect[j].add(i)
    
p=list(range(N))
def find(x):
    if x!=p[x]: p[x]=find(p[x])
    return p[x]

subtree=[[i,1] for i in A] # max val and ct of max val in a sub_tree.
ct=0
for new_node in sorted(range(N),key=lambda x: A[x]): # add nodes from low to high to neighbor sub-trees
        x=find(new_node)

        for neighbor in connect[new_node]:
            y=find(neighbor)
            
            if A[neighbor]<=A[new_node] and x!=y:  #  ignore neighbor with val>A[new_node] because they will be added later.     
            
                if subtree[y][0]==A[new_node]: # check how many nodes in the subtree have the same val of the new_node
                    ct+=subtree[x][1]*subtree[y][1]
                    subtree[x][1]+=subtree[y][1]
                p[y]=x # union new_node and the subtree
                
        
return ct
30
Show 11 replies
Reply
Share
Report
sourin_bruh's avatar
Sourin Majumdar

3182
September 25, 2022 9:52 AM

Read More
Anyone here after Weekly 312? 💀💀💀

8
Show 1 reply
Reply
Share
Report
SaraHassanAwwad's avatar
Sara

7
September 3, 2023 10:36 PM

Read More
exactly same question: https://leetcode.com/problems/number-of-good-paths/

4
Reply
Share
Report
prayas2410's avatar
Prayas Chaudhary

17
Last Edit: July 26, 2022 1:59 PM

Read More
Java Solution -> https://leetcode.com/playground/G2TDaY4V
Explanation -> https://pastebin.com/vTHjwnqA

4
Show 8 replies
Reply
Share
Report
grawlixes's avatar
grawlixes

5565
Last Edit: September 25, 2022 9:44 PM

Read More
Pretty sure this is correct, I tested it on a few sample inputs, but let me know if you see bugs. O(NlgN) total time and O(N) space using union find.


# Time complexity: O(NlgN) for sorting, O(N) for union find
# Space complexity: O(N) for the various structures used
def specialPaths(n, edges, a):
    # this insertion just lets us access node values by index
    # instead of (index - 1)
    a.insert(0, None)

    # adjacency graph for the list of edges
    e = [set() for i in range(n + 1)]
    for i,j in edges:
        e[i].add(j)
        e[j].add(i)

    # union find components
    toComp = [i for i in range(n + 1)]
    toSet = [{i} for i in range(n + 1)]

    # valNodes[v] = set([i, j, ...]) ->
    # nodes i, j, ... have value v
    valNodes = {}
    for i in range(1, n + 1):
        v = a[i]
        if v not in valNodes:
            valNodes[v] = set()
        valNodes[v].add(i)


    # start from smaller values, add them to the graph,
    # and keep track of how many instances of a new value
    # v exist in each component. for a component with k
    # copies of v, the number of paths in that component is
    # k * (k - 1) // 2. 
    ret = 0
    for v in sorted(valNodes.keys()):
            # componentCount[i] = k means that the ith union component
            # contains k occurrences of our current item v
            componentCount = {}
            for i in valNodes[v]:
                gi = toComp[i]
                componentCount[gi] = componentCount.get(gi, 0) + 1

            for i in valNodes[v]:
                for j in e[i]:
                    if a[j] <= a[i]:
                        # i has a neighbor less than or equal to itself,
                        # so we can merge groups of j and i together
                        gi, gj = toComp[i], toComp[j]
                        si, sj = toSet[gi], toSet[gj]

                        if gi == gj:
                            continue
                            
                        # merge elements from the smaller group into
                        # the larger group to maintain O(N) total
                        # time complexity for this part
                        if len(si) > len(sj):
                            gi, gj = gj, gi
                            si, sj = sj, si

                        while len(si) > 0:
                            k = si.pop()
                            toComp[k] = gj
                            sj.add(k)

                        oldCount = componentCount.get(gi, 0)
                        curCount = componentCount.get(gj, 0)
                        ret += oldCount * curCount
                        componentCount[gj] = oldCount + curCount
            
        return ret
4
Show 2 replies
Reply
Share
Report
Lakshaysk's avatar
Lakshay

120
July 12, 2022 8:04 AM

Read More
This problem was in my OA round and took too long to solve. EOD it sucks!


#include<bits/stdc++.h>
#define int long long
#define pb push_back
#define fr first
#define sc second
#define pii pair<int, int>
#define vi vector<int>
#define mod 1000000007
#define sz(x) (int)((x).size())
#define all(x) (x).begin(), (x).end()
#define FOR(i, a, b) for (int i = a; i < b; i++)
#define INF 3000000000000000000
#define endl "\n"
using namespace std;
const int N = 1e5 + 5;
int par[N], sz[N];
vector<map<int, int>> cnt(N);
vector<int> g[N];
int val[N];
int ans = 0;
void init(int n)
{
    for (int i = 0; i < n; i++)
    {
        par[i] = i;
        sz[i] = 1;
        cnt[i][val[i]]++;
    }
}
int find_set(int v)
{
    if (v == par[v])
    {
        return v;
    }
    return par[v] = find_set(par[v]);
}
void union_sets(int a, int b, int cur_val)
{
    a = find_set(a);
    b = find_set(b);
    if (a != b)
    {
        if (sz[a] < sz[b])
        {
            swap(a, b);
        }
        par[b] = a;
        sz[a] += sz[b];
        ans += cnt[a][cur_val] * cnt[b][cur_val];
        cnt[a][cur_val] += cnt[b][cur_val];
    }
}
void clr(int n)
{
    FOR(i, 0, n)
    {
        par[i] = i;
        sz[i] = 1;
        g[i].clear();
        cnt[i].clear();
    }
}
void TEST_CASE()
{
    int n;
    cin >> n;
    clr(n);
    for (int i = 0; i < n - 1; i++)
    {
        int u, v;
        cin >> u >> v;
        u--;
        v--;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    vector<pair<int, int>> p;
    for (int i = 0; i < n; i++)
    {
        cin >> val[i];
        p.push_back({val[i], i});
    }
    init(n);
    sort(begin(p), end(p));
    int j = 0;
    ans = 0;
    while (j < n)
    {
        int cur_val = p[j].fr;
        int i = j;
        while (i < n && p[i].fr == p[j].fr)
        {
            int node = p[i].sc;
            for (auto &u : g[node])
            {
                if (val[u] <= cur_val)
                {
                    union_sets(u, node, cur_val);
                }
            }
            i++;
        }
        j = i;
    }
    cout << ans << endl;
}
signed main()
{
    int t = 1;
    cin >> t;
    while (t--)
    {
        TEST_CASE();
    }
    return 0;
}
3
Show 5 replies
Reply
Share
Report
shashank0x1's avatar
Shashank Yadav

18
July 11, 2022 1:09 PM

Read More
can someone provide a c++/Java version of the solution
its little hard to follow

3
Show 2 replies
Reply
Share
Report
vavishalarya's avatar
Vishal Arya

4
July 12, 2022 12:14 PM

Read More
Can someone provide the links to more problems based on trees or graphs just like this one?

2
Show 1 reply
Reply
Share
Report
Sigurdsson's avatar
Sigurdsson

51
July 15, 2022 2:36 AM

Read More
As it's a tree, we know:


There are no cycles (satisfies 1st requirement)
Every 2 nodes has a unique path from one to the other (2nd requirement)
Thus, from each value that is the value of at least 2 nodes in the tree, we run dfs from one of the nodes and check if we can mark all others without traversing a node with a greater value.


Here's my solution, I guess it's considered as brute-force solution:


from collections import deque, defaultdict

def specialPaths(edges: list, A: list):
    A = deque(A)
    A.appendleft(None)
    n = len(A)
    graph = defaultdict(set)
    valToIndex = defaultdict(list)
    paths = 0
    
    for u, v in edges:
        graph[u].add(v)
        graph[v].add(u)
    
    for i in range(1, n):
        valToIndex[A[i]].append(i)
    
    def dfs(v, maxValue, marked):
        marked.add(v)
        
        for u in graph[v]:
            if A[u] <= maxValue and u not in marked:
                dfs(u, maxValue, marked)
        
    for val, indices in valToIndex.items():
        if len(indices) < 2:
            continue
        
        marked = set()
        dfs(indices[0], val, marked)
        paths += len(marked & set(indices)) - 1
        
    return paths
    
edges = [(1,2), (1,3), (3,4), (3,5)]
A = [2,3,1,2,3]

assert specialPaths(edges, A) == 2
1
Reply
Share
Report
2019csb1077's avatar
Super User

171
July 11, 2022 2:23 PM

Read More
Do you have more google OA question. If you have, please upload them too.

https://leetcode.com/discuss/interview-question/2258800/Google-or-OA

Google | OA
11
Tushakar's avatar
Tushakar Bhardwaj

14
July 9, 2022 7:22 PM

1.8K VIEWS

Special Paths


You are given the following:


A Tree with N nodes
An array denoting the value of each node
A path is called special path if following conditions are satisfied


All nodes in the path are traversed exactly once.
The value of starting node and terminating node in the path is same and starting node ≠terminating node.
The values of any node in the path are not greater than tha value of starting node.
Task
Count the number of special paths in the tree.


Note: Two paths are different if they contain atleast on different node.


Constraints:
2<=N<=10^5
1<=A[i]<=10^9 ∀i ∈[1,N]
It is guaranteed that given input forms a tree.


Example:-
N = 5
edges =[{1,2},{1,3},{3,4},{3,5}]
A = [2,3,1,2,3]


Output: 2
Explanation:-


Path -- 1{2} -> 3{1} ->4{2}
Path -- 2{3} ->1{2} ->3{1} -> 5{3}
Thus the answer is 2.

google
new grad
india
Comments: 2
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
leetcode_dafu's avatar
leetcode_dafu

2616
July 10, 2022 6:05 PM

Read More
union find solution https://leetcode.com/discuss/interview-question/2260088/special-path-google-oa-july-2022-graph/1480733

1
Reply
Share
Report
ishrivastava25's avatar
Shivendra Shrivastava

9
July 10, 2022 11:11 AM

Read More
Can anyone drop link to this ques or any related ques?

1
Reply
Share
Report
https://leetcode.com/discuss/interview-question/2258509/Google-India-OA-oror-July-2022
Fully functional and running python code with comments, random input generation and validation using the answers from brute method for Question 1 COUNT PAIRS:


import random


def optimized_solver(n, c, d, A, B):
    X = d - c
    Z = [0] * n  # Difference Array
    for i in range(n):
        Z[i] = A[i] - B[i]
    ans = 0  # Count of elements which satisfy this property

    def merge_sort_recursive_utility(l, r):
        nonlocal ans
        # Partition base case.
        if r == l:
            return

        # Partitioning step. NOTE: All indices are inclusive
        mid = (l + r) // 2
        merge_sort_recursive_utility(l, mid)
        merge_sort_recursive_utility(mid + 1, r)

        # Merging step
        lo = lo_merge = l  # Two lo pointers: one for merging and one for forming pairs
        hi = hi_merge = mid + 1  # Two hi pointers: one for merging and one for forming pairs
        arr = []  # Merged sorted array

        # Basically do the merging that we do while sorting.
        # Apart from that we also maintain two other pointers to check for answers
        while lo_merge <= mid and hi_merge <= r:
            # The usual sorting step
            left_val, right_val = Z[lo_merge], Z[hi_merge]
            if left_val > right_val:
                arr.append(right_val)
                hi_merge += 1
            else:
                arr.append(left_val)
                lo_merge += 1
            # This is the main solving part.
			# Basically lo is our i candidate and hi is out j candidate
            # Since lo is in lower array and hi is in higher index array. i < j is always satisfied.
            # If Z[lo] - Z[hi] <= X is satisfied for current values of lo and hi.
            # Then since values to the right of hi in the 2nd array are larger than Z[hi],
			# They too will satisfy the condition for lo. Let a value to right of hi in 2nd array be Z[hi] + p,  Since it is larger than Z[hi] and p is non -ve(either 0 or +ve value)
			# So, Z[lo] - (Z[hi] + p) => Z[lo] - Z[hi] - p => Since Z[lo] - Z[hi] was itself <= X, then subtracting a non -ve value will definitely we smaller than X.
            # Hence all values including and to the right of hi can form pair with lo. Hence we add r - hi + 1 to ans that is the length of array to right of hi in 2nd array.
            # If Z[lo] - Z[hi] > X, then no point in looking forward of hi for current value of lo, hence lo++. If current dont satisfy, then later values wont satisfy the property too.
            if Z[lo] <= Z[hi] + X:
                ans += r - hi + 1
                lo += 1
            else:
                hi += 1

        # If some values still remains, we must also add them to the sorted array
        while lo_merge <= mid:
            arr.append(Z[lo_merge])
            lo_merge += 1
        while hi_merge <= r:
            arr.append(Z[hi_merge])
            hi_merge += 1

        # Update the original array with sorted one.
        for j in range(l, r + 1):
            Z[j] = arr[j - l]

    merge_sort_recursive_utility(0, n - 1)
    return ans


# Brute method to verify our answer
def brute_method_solver(n, c, d, A, B):
    ans = 0
    for i in range(n - 1):
        for j in range(i + 1, n):
            if A[i] - A[j] + c <= B[i] - B[j] + d:
                ans += 1
    return ans


# Random input generator to generate random inputs and validate our answers
def random_input_generator(test_size):
    for _ in range(test_size):
        n = random.randint(2, 20000) # Can also run for 2*10^5, but will take time if brute method is also running
        c, d = random.randint(0, 100), random.randint(0, 100)
        a, b = [], []
        for i in range(n):
            a.append(random.randint(1, 10 ** 9))
            b.append(random.randint(1, 10 ** 9))
        # Use this to check answers from both approaches, may take 10-20 seconds due to O(n^2) brute method also running.
        # print('Got:', optimized_solver(n, c, d, a, b), "but Expected:", brute_method_solver(n, c, d, a, b))
        # Use this to run only optimized version, runs almost instantaneously
        print('Got:', optimized_solver(n, c, d, a, b))


def custom_input_runner():
    t = int(input())
    while t:
        t -= 1
        n, c, d = int(input()), int(input()), int(input())
        a = list(map(int, input().split(" ")))
        b = list(map(int, input().split(" ")))
        # Use this to check answers from both approaches, may take 10-20 seconds due to O(n^2) brute method also running.
        print('Got:', optimized_solver(n, c, d, a, b), "but Expected:", brute_method_solver(n, c, d, a, b))
        # Use this to run only optimized version, runs almost instantaneously
        # print('Got:', optimized_solver(n, c, d, a, b))


random_input_generator(5)
2
Reply
Share
Report
siddhantgupta384's avatar
Siddhant Gupta

9
Last Edit: July 9, 2022 7:58 PM

Read More
Just create mx , len variables
compare them at each dfs call , increment the cnt.




int mx =INT_MIN;

int cnt =0;
vector<int> vis;
map<int, int> mp;
void dfs(vector<vector<int>>&adj, int ind , vector<int>& val , int len ){

    vis[ind] =1;

    mp[val[ind]]++;
    int tmp = mx;
    mx = max(mx ,mp[val[ind]]);
    len++;
    if( mx >= (len+1)/2) {
        // cout<<ind<<" ";
        cnt++;
    }
    for( auto c: adj[ind]){
        if(!vis[c] and c != ind)
            dfs(adj , c  , val , len);
    }

    mp[val[ind]]--;
    len--;
    mx = tmp;
    vis[ind] =0;


}
int main(){

    int n ; cin>>n;
    vector<int> val(n);
    vis = vector<int> (n, 0);
    for( int i =0 ; i<n ; i++) cin>>val[i];
    vector<vector<int>>adj(n);
    for( int i =0 ; i<n -1; i++){
        int a, b;
        cin>>a>>b;
        a--;b--;
        adj[a].push_back(b);
        adj[b].push_back(a);
    }

    dfs(adj , 0 , val , 0);

    cout<<cnt<<endl;
    

}
1
Show 2 replies
Reply
Share
Report
aman282571's avatar
innocentCoder
1757
July 9, 2022 7:51 PM

Read More
Q.1 can be solved using BIT or segment tree. Use array a[i]-b[i]+c for creating BIT on the go and query using a[j]-b[j]+d
Q.2 we can maintain node to freq map and a set of {freq,node}(to find max frequency) .

1
Show 2 replies
Reply
Share
Report
temp_rand's avatar
Alt

38
Last Edit: July 9, 2022 6:50 PM

Read More
1st qn can be reduced to


given array [n] find number of (i,j) such that a[i]-a[j]<=k


first sort the array and do binary search in the right of i for no of j for particular i


TC : O(nlogn)


int noOfPairs(vector<int>a,vector<int>b,int c,int d)
{
    int n = a.size();

    for(int i=0;i<n;i++)
    {
        a[i]-=b[i];
    }

    int k = d-c;

    int ans =0;

    sort(a.begin(),a.end());

    for(int i=0;i<n-1;i++)
    {
        auto it = lower_bound(a.begin()+i+1,a.end(),k+a[i]);
        if(it==a.end()) ans+=(n-i-1);
        else if(*it==k+a[i]) ans+=(it-a.begin()-i);
        else ans+=(it-a.begin()-i-1);
    }

    return ans;

}
1
Show 7 replies
Reply
Share
Report
chandr_a0056's avatar
Chandra

30
July 10, 2022 5:35 PM

Read More
You can check my solution below


#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
#pragma GCC optimize("O2")
using namespace std;
using namespace __gnu_pbds;

typedef tree<int, null_type, less_equal<>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;

signed main()
{

int t = 1;
cin >> t;
while (t--)
{

 int n, i, x, ans = 0, c;
 map<int, int> mm;
 ordered_set o_set;

 cin >> n;
  int d;
 cin >> c >> d;

 vector<int> a(n, 0), v, b(n, 0);

 for (i = 0; i < n; i++)
   cin >> a[i];

 for (i = 0; i < n; i++)
  cin >> b[i];
 
  


 x = c - d;
 int sz=0;
 int xx=0;


 for (i = n - 1; i >= 0; i--)
 {
   int pp = a[i] - b[i] + x;
   mm[a[i] - b[i]]++;
  
   xx = sz-o_set.order_of_key(pp);
   ans+=xx;
   o_set.insert(a[i] - b[i]);
    sz++;
 }
 cout << ans << endl;
}
}

0
Reply
Share
Report
user0036Hq's avatar
Rockey Chauhan

20
July 9, 2022 7:54 PM

Read More
This are medium to hard questions. If you are able to do 1.5 questions, I think you will get interview call !!

0
Show 1 reply
Reply
Share
Report
huangshan01's avatar
Shan

341
July 9, 2022 7:12 PM

Read More
Q1, rework the formula, it's actually diff[i] - diff[j] <= d - c. Build sorted suffix diff array reversely, then each index, binary serach in suffix array to find its contribution.


Q2 is a union find problem. Start lowest, union all 1's, each union, comb(count[1], 2) is the number of paths. Move to 2 union 2's with 1's, repeat counting. Then 3, union 3's with 1's and 2's, repeat counting. Keep going.

0
Show 2 replies
Reply
Share
Report

https://leetcode.com/discuss/interview-question/805468/Google-or-OA-or-SDE-(2020)or-India
Google | OA | SDE (2020)| India
28
Anonymous User
Anonymous User
Last Edit: August 22, 2020 5:49 PM

6.7K VIEWS

Duration: 1Hr


Given array A of N Integers a1 ,a2, a3...... aN . You are also given two integers S and M. You can pick subarray of size S where you have to perform M operation by incrementing the value of each element value by 1. Find the maximum value of minimum value in array A.
Example
Input:
N = 6 ,M = 5 ,S =2
1 2 3 4 5 6
Output:
4
Explaination:
1st opertaion subarray index range (0,1) 2 3 3 4 5 6
2nd opertaion subarray index range (0,1) 3 4 3 4 5 6
3rd opertaion subarray index range (0,1) 4 5 3 4 5 6
4th opertaion subarray index range (2,3) 4 5 4 5 5 6
5th opertaion subarray index range (0,1) 5 6 4 5 5 6

You are given an array of N elements. You are allowed to delete at maximum one element from the provided array. The order of elements remains the same in the resultant array. You are required to maximize the number of subarrays that contain both maximum and minimum elements of the resultant arary.
Constraints
TestCases [1,10]
N [1,105]
1<= arri<=109
Input
6
7 2 5 4 3 1
Output
4
Explaination
If we delete 1 from the array then resultant arary will be 7 2 5 4 3. So the number of subarrays which will contain maximum 7 and minimum 2 will be 4
[7,2]
[7,2,5]
[7,2,5,4]
[7,2,5,4,3]

https://leetcode.com/discuss/interview-question/796729/Google-Online-Assesment-Question-SWE-2021
Google Online Assesment Question - SWE 2021
2
sammy_91's avatar
Saumya Mishra
51
Last Edit: August 17, 2020 4:45 PM

499 VIEWS

Minimum Difference


Given a string of 'b's and 'w's. We can take as many characters as we want from the start and can append it in end of string, but sequence of characters should remain same. What can be minimum number of characters we need to flip('b' to 'w' or 'w' to 'b') in order to make string an alternate sequence of 'b's and 'w's , i.e. "bwbwbwbwb" or "wbwbw" ...


TestCases :


"wwb" - 0
"bwwwbbbbb" - 3
"wwwwwbbww" - 3
"bbwbww" - 2
"bww" - 0
"wbbww" - 1
I don't remember other test cases. If anyone have detailed question please share. Feel free to share your approaches.

google
strings
india
https://leetcode.com/discuss/interview-question/794982/Google-OA-SWE-Intern-2021-India
Google OA SWE Intern 2021 India
4
Anonymous User
Anonymous User
Last Edit: August 17, 2020 7:50 PM

1.0K VIEWS

myself - A Final Year Student from Tier 3 college. I applied for Summer Internship role through Google's carrier site.


platform - HackerEarth
test pattern - 2 Coding Questions (1 hour)


Question 1 - N boxes are Arrranged in a line. Each box is colored either with white or black. You can select any number of boxes from the starting and put it behind the last box in the same sequence as it was placed initially. you can perform this operation atmost once.
For example string s="wbbb" . In one operation you can select "wb" and from the start and put it behind the last box "b".


Note: you cannot select all the n boxes.


You are required to find the minimum number of boxes whose colors must be reversed so that all the boxes in the sequence are of an alternate color, that is any two adjacent boxes are of different colors.


Input :  5
wwwwwbbww
wwwb
bwww
wwww
bbbbb

Output : 
3
1
1
2
2
my code


#include<bits/stdc++.h>
using namespace std;
 
const int N = 2e5 + 5;

string str;
void sol()
{
	cin>>str;
	string s;
	int m1=str.find("bw");
	int m2=str.find("wb");
	if(m1>m2)
	s=str.substr(m1,str.length())+str.substr(0,m1);
	else if(m2>m1)
	s=str.substr(m2,str.length())+str.substr(0,m2);
	else
	s=str;
	int a=0,b=0;
	for(int i=0;i<s.length();i+=2)
	{
		if(s[i]!='b')
		a++;
	}
	for(int i=1;i<s.length();i+=2)
	{
		if(s[i]!='w')
		a++;
	}
	for(int i=0;i<s.length();i+=2)
	{
		if(s[i]!='w')
		b++;
	}
	for(int i=1;i<s.length();i+=2)
	{
		if(s[i]!='b')
		b++;
	}
	cout<<min(a,b)<<endl;
}
int32_t main()
{
	IOS;
	int t;
	cin >> t;
        //t=1;
	while(t--)
	{
		sol();
	}
	return 0;
}
Correct me if i'm wrong..


Question 2 - You are given a tree of N nodes. The tree is rooted at node 1.Each tree node has a value associated with it and it is represented as value(i). for each node you are required to determine the closest ancestor that contains values that are co-primes to the current node value. If no such nodes exists then print -1.


Input format
first line T no.of Test cases.
first line of each test case contains an integer N denoting the number of nodes in the tree.
Next line contains N integers where i-th integer denotes value at node i (value(i)).
Next N-1 lines contains 2 space seperated integers u and v denoting an edge between u and v.


Input : 
2
8
16 17 12 7 20 18 7 8
6 8
3 8
8 1 
2 7
2 3 
7 5 
2 4
6
5 19 12 10 9 16
4 3
5 3
6 2
6 1
4 6

Output :
-1 3 -1 2 7 -1 2 -1
-1 6 1 -1 4 1
However I failed to answer this..!

google
intern
online assessment
india
google interview
google intern
swe intern
google interview question
2021
Comments: 5
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
lakshay149's avatar
Lakshay

20
July 3, 2022 1:27 PM

Read More
Here is my clean code using prefix and suffix arrays.
prefix[I][0]=min no of reversal required for string [0, i] starting with 'b'
prefix[i][1]= min '' '' '' '' starting with 'w'
suffix[i][0]=min '' '' '' for string [i,n] ending with 'b'
suffix[i][1]=min '' '' 'for string [i,n] endgin with 'w'


two case are possible:-


suffix[i,0]+prefix[i-1][1]
2)suffix[i,1]+prefix[i-1][0]
find minimum of these .


//code begins here
int main() {
int t;
cin>>t;
while (t--){
string s;
cin>>s;
int n=s.size();
vector <vector> prefix(n,vector (2,0)),suffix(n,vector(2,0));
if (s[0]=='b') {prefix[0][0]=0;prefix[0][1]=1;}
else {prefix[0][0]=1;prefix[0][1]=0;}
for (int i=1;i<n;i++){
if ((i+1)%2==0){
if (s[i]=='b'){
prefix[i][0]=1+prefix[i-1][0];
prefix[i][1]=prefix[i-1][1];
}
else {prefix[i][0]=prefix[i-1][0];prefix[i][1]=1+prefix[i-1][1];}
}
else {
if (s[i]=='b'){
prefix[i][0]=prefix[i-1][0];
prefix[i][1]=1+prefix[i-1][1];
}
else {prefix[i][0]=1+prefix[i-1][0];prefix[i][1]=prefix[i-1][1];}
}
}


if (s.back()=='b') {suffix[n-1][0]=0;suffix[n-1][1]=1;}
else {suffix[n-1][0]=1;suffix[n-1][1]=0;}
int cnt=0;
for (int i=n-2;i>=0;i--){
    
    if ((cnt+1)%2!=0) {
        if (s[i]=='b') {
            suffix[i][0]=1+suffix[i+1][0];
            suffix[i][1]=suffix[i+1][1];
        }
        else {
              suffix[i][0]=suffix[i+1][0];
            suffix[i][1]=1+suffix[i+1][1]; 
        }
    }
    else {
           if (s[i]=='b') {
            suffix[i][0]=suffix[i+1][0];
            suffix[i][1]=1+suffix[i+1][1];
        }
        else {
              suffix[i][0]=1+suffix[i+1][0];
            suffix[i][1]=suffix[i+1][1]; 
        }
        
    }
    cnt++;
}

int ans=min(prefix[n-1][0],prefix[n-1][1]);

ans=min(suffix[0][0],suffix[0][1]);

for (int i=1;i<(n-1);i++) {
    int temp=min(suffix[i][0]+prefix[i-1][1],suffix[i][1]+prefix[i-1][0]);
  
    ans=min(ans,temp);
}
cout<<ans<<endl;

} 
}

0
Reply
Share
Report
2019csb1077's avatar
Super User

171
July 21, 2021 3:39 PM

Read More
For the first problem,
What we can do is brute force the solution.
We can one by one remove from the i length substring from the beginning and add it to the end, not in the literal sense but we can simulate so by keeping count of the number of black and white balls present in the even and odd positions.
And suppose the original string is bwwwb. (consider 1 indexing)
odd => b = 2 , w = 1
even => b = 0, w = 2
If we remove substring of length 1, then the string will become wwwbb
and
even=> b = 1 , w = 1
odd=> b = 1, w = 2
.
We can calculate them easily by keeping prefix sums of black and white respecitvely.
And for each configuration, we can calculate the answer for that configuration by min(even) + min(odd)


And we take minimum for all possible configutations


time complexity : O(n)

0
Reply
Share
Report
KeepMotivated's avatar
Tarun Singla

563
Last Edit: March 4, 2021 6:01 PM

Read More
FOR FIRST QUESTION
I dont know whether your approach here is my approach
we can always try for all possibilities using precomputation and dp that will always work I don't know if your code will work for always
see wbwwbwbbbwwwww
if we are shifting wbww | bwbbbwwwww
if we are shifting till I have placed this | we can calculate from precomputing if bwbbbwwwww its starting character is b or w from backward traversal and for wbww using backward traversal as wbww will be at backward after we shifted. this I will calculate for all indices that I will take the minimum from all
dpforward[0] will traverse from forward with w at starting
dpforward[1] will traverse from forward with b at starting
similarly is backward
below is my code


#include<bits/stdc++.h>
using namespace std;
#define int long long
#define f(i,a,n,b) for(int i = a;i<n;i+=b)
#define sz(x) ((int)(x).size())
#define pb push_back
#define F first
#define S second
const int mxN = 2e5, mod = 1e9 + 7;
const int INF = 1e18;
int32_t main()
{
#ifndef ONLINE_JUDGE
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
#endif
string s;
cin >> s;
int n = s.size();
int dpforward[n][2] = {0};
int dpbackward[n][2] = {0};
char c1 = 'w';
char c2 = 'b';

// calculating forward
for (int i = 0; i < n; i++)
{
    // startswith w
    if (s[i] != c1)
    {
        dpforward[i][0] += 1;
    }
    if (i > 0)
    {
        dpforward[i][0] += dpforward[i - 1][0];
    }

    if (c1 == 'w')
    {
        c1 = 'b';
    }
    else
    {
        c1 = 'w';
    }
    // startswith b
    if ( s[i] != c2)
    {
        dpforward[i][1]++;

    }
    if (i > 0)
    {
        dpforward[i][1] += dpforward[i - 1][1];
    }

    if (c2 == 'b')
    {
        c2 = 'w';
    }
    else
    {
        c2 = 'b';
    }
}

// backward propogation 
c1 = 'w';
c2 = 'b';
for (int i = n - 1; i >= 0; i--)
{
    // startswith w
    if (s[i] != c1)
    {
        dpbackward[i][0] += 1;
    }
    if (i < n - 1)
    {
        dpbackward[i][0] += dpbackward[i + 1][0];
    }

    if (c1 == 'w')
    {
        c1 = 'b';
    }
    else
    {
        c1 = 'w';
    }
    // startswith b
    if ( s[i] != c2)
    {
        dpbackward[i][1]++;

    }
    if (i < n - 1)
    {
        dpbackward[i][1] += dpbackward[i + 1][1];
    }

    if (c2 == 'b')
    {
        c2 = 'w';
    }
    else
    {
        c2 = 'b';
    }
}

// for zero shifting 
int answer = min(dpforward[n - 1][0], dpforward[n - 1][1]);



for (int i = 1; i < n; i++)
{
    // startswith w
    // if((n-i)%2==0)
    // {
    //     answer = min(answer , dpbackward[i][1] + dpforward[i-1][0]);
    // }
    // else
    // {
    //    answer = min(answer , dpbackward[i][0] + dpforward[i-1][1]);
    // }
    // // startswith b
    // if((n-i)%2==0)
    // {
    //     answer = min(answer , dpbackward[i][0] + dpforward[i-1][1]);
    // }
    // else
    // {
    //    answer = min(answer , dpbackward[i][1] + dpforward[i-1][0]);
    // }
    
    // we can direclty write
    answer = min(answer , dpbackward[i][1] + dpforward[i - 1][0]);
    answer = min(answer , dpbackward[i][0] + dpforward[i - 1][1]);
}
cout << answer << "\n";
return 0;
}
0
Reply
Share
Report
mohan_r's avatar
mohan_r
1
August 20, 2020 12:31 PM

Read More
Can you explain the logic behind choosing the greater index for appending
int m1=str.find("bw");
int m2=str.find("wb");
if(m1>m2). // why you are choosing the greater index, any proofs the greater index will always work
s=str.substr(m1,str.length())+str.substr(0,m1);
else if(m2>m1)
s=str.substr(m2,str.length())+str.substr(0,m2);
else

0
Reply
Share
Report
abhjkgp's avatar
Abhijay Mitra
10
August 19, 2020 7:41 AM

Read More
What is your logic behind first one

https://leetcode.com/discuss/interview-question/794974/Google-Coding-Challenge-Intern-India
Google Coding Challenge Intern India
6
Anonymous User
Anonymous User
August 16, 2020 5:28 PM

3.7K VIEWS

Hi all! Today I gave the google coding challenge for interns, and I recieved the following two questions.
Question 1
There are N words in a dictionary such that each word is of fixed length M, and consists of only lower case english alphabets. A query word Q also has length M. Query word also contains only lower case english alphabets but at some places instead of an alphabet it has "?". match_count of Q, is the count of words in the dictionary (already populated with words of same length M) and contains the same english letters (excluding the letter that can be in the position of ?) in the same position as the letters are there in the query word Q. Your are given the query word Q and you have to find the match_count.


Input Format


First line contains two space seperated integers N and M denoting the number of words in the dictionary and the length of each word
Next N line contains the words in the dictionary
Next line Q contains the number of query words
Next Q lines contain one query word each
Output
For each query word output the match_count


Constrains
1<=N<=5x10^4
1<=M<=7
1<=Q<=10^5
Time Limit: 1 second


Sample Input:


cat
map
bat
man
pen
4
?at
ma?
?a?
??n
Sample Output


2
2
4
2
Solution:
We can build a trie from the words given in the dictionary and the nodes in the trie can be used to get the match_count. I had seen a similar DS design question in one of the montly leetcode challenge


Question 2
You are given a list S which initially contains 0. You must perform Q queries of the following type:


0 X: insert X in to the list
1 X: For every element A in S, replace A with A XOR X
After performing Q queries return the resulting array in a sorted manner


Constraints:
1<=T<=100
1<=Q<=10^6
0<=X<=10^9
Time Limit: 1 second


Sample Input


1
5
0 4
0 2
1 4
0 5
1 8
Sample Output
8 12 13 14


Soultion: I did the naive approach for query of type 0 I just appended the number to the list and for the query of type 1 I loop over the entire array and XOR each array element with the current query element. I was only able to solve this question partially as for last 5 test cases my solution was exceeding the time limit.


Could anyone help me with a more optimised approach for this problem?

https://leetcode.com/discuss/interview-question/787119/125-days-of-Google-Interview-or-Software-Engineer-L4-or-Accepted-or-India

Explore
Problems
Contest
Discuss
Interview
Store
0

avatar
Back
125 days of Google Interview | Software  Engineer L4 | Accepted | India
76
Anonymous User
Anonymous User
Last Edit: August 13, 2020 2:41 PM

16.4K VIEWS

I know for the candidates whose interview process are ongoing, its really tough to blindly wait for what-next and when! In this post I will be sharing day wise timeline of the whole process that happened, I am sure this will give a good idea on your interview process ahead.


Day 1: First interaction with recruiter
He briefed me about the interview process and also asked 10 objective type questions. Asked me how much time I need to prepare. I told him, I need some time, so he scheduled next call for to check how my preparation is going.


Day 20: Preparation check by recruiter
Unfortuanerly he informed me that hiring is on hold due to pandemic, but asked me to continue with my preparation and said he will get back to me as soon as he get more information on hiring.


Day 50: Ready for interview
Recruiter asked me five different dates to schedule telephonic interview. Also told me that most of the interviewers are US based, so interviews will be mostly occurring late night.


Day 75: Phone Interview
He asked 3 variants of a simple graph based problem. For each variant it required me to optimize it in a different dimension.


Day 78: Phone Interview Result
Recruiter said I did positively well in the interviews.He also introduced me to the india based recruiter for virtual onsite rounds and said she will be my point of contact for all the further interviews.


Day 84: First mail from Indian recruiter
First mail from the new recruiter, where she scheduled a discussion meeting.


Day 89: Discussion with the recruiter
Again she briefed me about the whole process of onsite interview, hiring committee etc. She also told me that ther will be 5 interviews, 4 problem solving and DS rounds and a googlyness round. Again the problem solving and DS rounds will be by US based interviewers and will be occurring late night. Whereas googlyness round will be conducted with an indian interviewer. She also told me that only 2 coding interviews will happen on a single day. I provided my preferred dates for interviews.


Day 95: First two coding virtual onsite interviews


Coding Round 1 : He asked a sliding window based problem where size of most optimal window has to be returned. Then we asked modified the problem where I had give 2 window where the size of the 2 window together has to be optimized.


Coding Round 2: This time the proble was based on pattern matching which requires me to implement Trie.


Day 96: Results for first two rounds
Call from recruiter, results for first 2 rounds were out and she said I did it very well and both the interviewers are inclined to hire.


Day 104: Remaining coding interviews and googlyness round


Googlyness : Interviewer said all his questions will be situation based, and I can either answer them w.r.t. my past job experience or if that situation never occurred I have to explain if it will occur what will you do.


Coding round 3: First of all interview didn’t start on time, had to call the recruiter late night as I din’t want to reschedule the interview to some other date. So requested her to reschedule it on the same night for any time slot. My interview the literally occurred at mid night, after round 4. This was also a very simple graph based problem, a bit open ended. The question has some data in beginning which requires preprocessing and then answering the queries. Interviewer then modified the questions a few time and then I had to update my solution accordingly. I also had to make certain written assumptions to solve the problem, which was appreciated by the interviewer.


Coding round 4: This round had just one problem, based on permutation and combination. I implemented it before time, so interview ended much before the expected time.


Day 105: Results for last three rounds
Got a call from recruiter, she said I did well on these interview as well. She the scheduled a meeting with prospective manager for discussing project.


Day 106: Project Call
Project call meeting with manager on the projects. He told me about the org, what they do. He explained me the projects and the teams he has under him.


Day 113: Package submitted to hiring committee
Recruiter called me and said, manager is inclined to hire me in his team, and now she is submitting my package to hiring committee.


Day 118: Compensation details
Recruiter asked me to share my compensation details including offer letters, payslips etc.


Day 119: Hiring Committe Result
Recruire called me to inform that the Hiring committee approved my package. She also sent me the initial compensation mail. We had a discussion (Negotiation Shhh...!) on that and she said she will talk to compensation team again.


Day 124: Revised Compensation
Recieved revised compensation, matching my requirements.


Day 125: Offer letter
Recieved the official offer letter and accepted the offer!!


Three thing that helped me to reach this point


Solved 375 problems on leetcode (75 easy, 200 medium & 100 hard) , also solved a couple of problems daily from different sites.


Failing google interview last year. It helped me understand what was missing from my preparation.


I am an active interviewer in my current organisation. This helped me understand what are the common mistakes we make as a candidate and also what as an interviewer our expectations are.


google
india
google interview
Comments: 14
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
temptaken's avatar
temptaken

65
August 16, 2020 3:44 PM

Read More
Hi Congratulations on your offer!! You don't have system design round ?

7
Show 1 reply
Reply
Share
Report
TheBeliever's avatar
Zorro

641
September 3, 2021 4:39 PM

Read More
How many hard did you encounter in interview?
I have a google interview coming up. Should I focus on Hard problems even for screening?

5
Reply
Share
Report
burner7's avatar
burner7

74
August 13, 2020 12:10 PM

Read More
Congratulations on your offer!!
Had just one doubt,
Day 118: Do they ask you to give your current payslips and then decide to offer a package or you are allotted a package according to your level (eg: L4 in your case) ?

2
Show 1 reply
Reply
Share
Report
sp140's avatar
sp140

228
March 2, 2021 8:03 PM

Read More
Congratulations on your offer and for the detailed interview experience!! Just wanted to ask - is competitive programming necessary to crack the Google interview (especially for the L4 position) or is Leetcode enough? I'm asking this as I see a lot of Google interview experiences where the candidates compare the interview questions to "Div2 C-D" (from codeforces rounds). And are you yourself a competitive programmer? Appreciate your response.

3
Reply
Share
Report
HalfPolygon's avatar
Half

40
August 17, 2020 11:07 AM

Read More
Congratulations! did you use Java or Python?

1
Show 1 reply
Reply
Share
Report
drnaredla's avatar
Dinesh Reddy Naredla

4
August 15, 2020 12:08 AM

Read More
Congratulations!!! Quick question, so there weren't any system design questions in any of your interview rounds?

1
Show 1 reply
Reply
Share
Report
black_ranger's avatar
Soumyadeep
222
August 14, 2020 8:52 PM

Read More
Congratulations on your offer!!
I saw that you are MTech degree holder,I just wanted if having a master's degree help you to climb the ladder quickly and move to a higher position in the company?

1
Show 1 reply
Reply
Share
Report
facelessman's avatar
facelessman
0
August 13, 2020 11:09 AM

Read More
Congratulations on your offer.


Appreciate if you could please share your years of experience and compensation details and previous company?


And also how did you get the call? Through some referral or LinkedIn?

0
Show 1 reply
Reply
Share
Report
shrutimk's avatar
shrutimk
0
October 28, 2022 8:18 PM

Read More
Hi, Congratulations!
It is amazing that you have already solved 375 problems! Such a big number!
Could you please guide on what is minimum number of problems we need to solve from leetcode and solving how many problems is good enough for Google interviews?
I
(Pardon me for asking too directly, have interviews scheduled next week)

0
Reply
Share
Report
MercLabs's avatar
Shreejit Ray Chaudhury
8
November 4, 2020 4:27 PM

Read More
HI, Congratulations on your success. Can you share your googlyness interview questions in a bit more detail?

https://leetcode.com/discuss/interview-question/764191/Google-phone-interview
Google phone interview
1
Anonymous User
Anonymous User
July 31, 2020 3:46 AM

638 VIEWS

Given songs with no of times played and genre, find most played song per genre with N memory (N is distinct genres)
Followup: Find k most played songs per genre.

google
india

https://leetcode.com/discuss/interview-question/633162/Google-Virtual-Onsite-April-2020-Bangalore
Google Virtual Onsite April 2020 Bangalore
17
Anonymous User
Anonymous User
Last Edit: May 16, 2020 6:32 AM

2.4K VIEWS

Question 1:
Merge Intervals With Labels


Question 2:
Card Game


Question 3:
Given an array of +ve numbers and another array of same size with zeros.
Here are the operations you're allowed to perform on the second array.


You're allowerd to increment only a subarray of values. [Subarray has to be a contiguous block]
You're allowerd to increment the values of the subarray by a value of 1.
How many increment operations does it require to transform second array of zeros to the first array?


Input:
[3, 4, 2, 5, 7]


Output: 9

google
india
bangalore
onsite
Comments: 9
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
muhandae's avatar
Raghu P
82
July 4, 2020 9:58 AM

Read More
For Q3, All the comments are discussing O(nlogn) or O(n^2) solutions, I have O(n) solution seems straight forward


Logic
Assume we know the answer for array of size n-1 elements and now we are trying to compute array of size n elements (1 new integer got added to the array at the end)
if the last element in the old array is greater than or equal to the newly added element then number of operations to add will be zero.
if the last element in the old array is less than the newly added element then number of operations to add will be newly added element - last element of old array


Code:


public int minOperations(int[] a) {
    if(a.length == 0) return 0;
    int res = a[0];
    for(int i=1; i<a.length; i++) {
        res += Math.max(0, a[i] - a[i-1]);
    }
    return res;
}
I didn't understand why no one has discussed about this, there can be two reasons


No one has thought about it
There is a case i am missing, If yes can anyone please suggest an example to prove that this is wrong
Waiting for some reply...

19
Show 1 reply
Reply
Share
Report
abhi2iitk's avatar
abhijit mondal

96
Last Edit: June 3, 2020 10:24 PM

Read More
For Q3, use segment tree to store and retrieve minimum element from index i to index j. Then recursively compute the min element and index from i to j, do operation with cost min_element_value-last_operation_value.


def seg_tree(arr, i, j, cache):
    if i == j:
        cache[(i, j)] = [i, arr[i]]
        
    else:
        k = int((i + j)/2)
        
        a = seg_tree(arr, i, k, cache)
        b = seg_tree(arr, k+1, j, cache)
        
        cache[(i, j)] = a if a[1] < b[1] else b
        
    return cache[(i, j)]

def get_min(cache, p, q, i, j):
    if (p, q) in cache:
        return cache[(p, q)]
    
    k = int((i + j)/2)
    
    if q <= k:
        return get_min(cache, p, q, i, k)
    elif p > k:
        return get_min(cache, p, q, k+1, j)
    else:
        a = get_min(cache, p, k, i, k)
        b = get_min(cache, k+1, q, k+1, j)
        
        return a if a[1] < b[1] else b
    
def increment_recur(cache, p, q, n, m):
    i, v = get_min(cache, p, q, 0, n-1)
    
    if p == q:
        return v-m
    
    a = increment_recur(cache, p, i-1, n, v) if i-1 >= p else 0
    b = increment_recur(cache, i+1, q, n, v) if i+1 <= q else 0
    
    return v - m + a + b
        
def increment(arr):
    cache = {}
    n = len(arr)
    seg_tree(arr, 0, n-1, cache)
    return increment_recur(cache, 0, n-1, n, 0)
O(n*logn)

2
Reply
Share
Report
BigOlogn's avatar
BigOlogn

5347
May 16, 2020 6:16 AM

Read More
How much exp you have ?

2
Reply
Share
Report
lehuy20's avatar
Le Huy
108
May 19, 2020 2:06 AM

Read More
Q3 can be solved in O(n) using cartesian tree. First build a tree then traverse it top down recursively summing together the difference between current node val and its parent val.

1
Reply
Share
Report
Chomusuki's avatar
Elie Maamary
63
Last Edit: May 17, 2020 10:45 PM

Read More
For Q3:


Let's think about this in reverse, assume you have buildings of different story heights in a row, with 1 move, you can destroy the lowest level of a contiguous segment of buildings and make them collapse by 1 level. Clearly, when given the chance, we want to collapse as many buildings as possible simultaneously. Now let's say we want to apply the operation on all buildings from i to j, i < j, how many times can we do it? We can do it as many times as the min in that range.


let m be the index of the min from i->j
ans(i, j) = A[m] + ans(i, m - 1) + ans(m + 1, j)


Implemented naively, this will take O(n^2) time. (Each time we find the min, we eliminate 1 element, so we find time min n times -> O(n^2) )
But we can use a segment tree to find the min of a range in log n time, making the time complexity O(nlogn)

1
Show 1 reply
Reply
Share
Report
Shradha1994's avatar
ss94

1928
May 15, 2020 10:42 PM

Read More
Question 2 - Similar question - https://leetcode.com/problems/stone-game-iii/
It is a DP question.

1
Reply
Share
Report
xiaoxiang615's avatar
Xiang Ji

1653
Last Edit: May 16, 2020 6:41 AM

https://leetcode.com/discuss/interview-question/576127/Need-help-in-a-question-asked-by-google

Need help in a question asked by google
0
Anonymous User
Anonymous User
Last Edit: April 13, 2020 1:14 AM

645 VIEWS

Given a board game of N x M size. A domino is of size 1 x 2 and can be rotated to make it 2 x 1. A player can place a domino in any of the available position. When a player is not able to place a domino, he loses. An AI is created to play against the user. The AI selects a random position in the board and places the domino there. Improve this AI. What solution will be the best when board size is small and what if the board size is large.


Anyone has any idea how to solve this problem?

onsite interview
google
india
swe
Comments: 4
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
songsari's avatar
songsari
552
Last Edit: April 13, 2020 5:46 AM

Read More
You are basically trying to build a search tree. If the board size is small, you can use minimax and build out the full tree.
If the board size is moderately large, you could apply alpha beta pruning to minimax. If the board size is extremely large, the problem becomes intractable. Then you could use an algorithm like Monte Carlo Tree Search. You just let the AI play the games tens of thousands of times and build an approximation of each state and transition.

2
Show 1 reply
Reply
Share
Report
ping999's avatar
810.650.440
214
April 13, 2020 9:45 AM

Read More
Here is a solution similar to 294. Flip Game II. When m and n is small you can brute force to find the best move. My solution is not optimized, but even with caching/memoiziation it is still (m*n)! time complexity.


# use 1d array to represent board, '.' is empty slot, 'x' is occupied slot:
# 3 by 4
# x...   -> x...xxx..... 
# xxx.
# ....

def canWin(board, m, n):
    moves = getPossibleMoves(board, m, n)
    if not moves:
        return False
    for move in moves:
        if not canWin(move, m, n):
            return True
    return False

def getPossibleMoves(board, m, n):
    mutable_board = [ list(board[i*n:i*n+n]) for i in range(m)]
    moves = []
    for i in range(m):
        for j in range(1, n):
            # horizontal placement
            if mutable_board[i][j] == mutable_board[i][j-1] == '.':
                mutable_board[i][j] = 'x'
                mutable_board[i][j-1] = 'x'
                moves.append( ''.join( [''.join(row) for row in mutable_board] ) )
                mutable_board[i][j] = '.'
                mutable_board[i][j-1] = '.'

    for i in range(1, m):
        for j in range(n):
            # vertical placement
            if mutable_board[i][j] == mutable_board[i-1][j] == '.':
                mutable_board[i][j] = 'x'
                mutable_board[i-1][j] = 'x'
                moves.append( ''.join( [''.join(row) for row in mutable_board] ) )
                mutable_board[i][j] = '.'
                mutable_board[i-1][j] = '.'
    return moves

def getBestMoves(m, n):
    board = '.' * (m*n)
    bestMoves = []
    for move in getPossibleMoves(board, m, n):
        if not canWin(move, m, n):
            bestMoves.append(move)
    return bestMoves
print(getBestMoves(3, 2)) # returns ['xx....', '..xx..', '....xx']
So for large m and n, this would not work. Monte carlo simulation can be used if the possible states are large. For each move, one of the simplest simulation can be performed is by each player taking turn randomly placing pieces until board is full, and see who is the winner. Simulate each move 1000x to see the probability of winning, and at the end pick a move with the highest winning probability. When the board states is small enough, we can go back to the brute force solution.

1
Show 1 reply
Reply
Share
Report
noot_noot's avatar
chris
36
April 13, 2020 12:28 AM

Read More
for what position is this for?

1
Reply
Share
Report
gerrob's avatar
Robert Gerbicz
1079
April 13, 2020 1:29 AM

Read More
There is at most 2 ^ (m * n) different positions, if m,n is small then you can tell which position is winner/loser, and from each winner position what is a good placement.
Work backwards.

0
Show 1 reply
Reply
Share
Report
https://leetcode.com/discuss/interview-question/494288/Google-Phone-Screen-Round
Google Phone Screen Round
5
Anonymous User
Anonymous User
Last Edit: February 13, 2020 9:39 PM

2.0K VIEWS

I got a mail from recuiter if I am interested in open positions because I took google foobar. They gave me enough time to prepare and when I was comfortable I took the call for interview.


I was interviewed on 8th Jan and the interviewer asked me these two questions.


Imagine an array class with only 3 operations GetAt(), SetAt() and SetAll(). Implement all the methods as O(1).
Given denominations D and a max value MAX, find the smallest set of coins that can exactly construct any value 1 <= n <= MAX.
**The explanation goes like this.
D is a vector, sorted increasing, which describes the monetary system; e.g. {1, 5, 10, 25} for a U.S. penny, nickel, dime, quarter.
MAX is in the same units as D.
The output should be a vector of the same order as D, where each coefficient is how many of that coin you have. "Smallest set" refers to the total number of coins in the set. Some inputs may have multiple equally good answers; you may choose any such answer.


The wasn't able to solve any of those. I provided solutions but they were not up to the mark.
The first one is pretty easy.


Edit:
For the second question I came up with a approach which i would like to share:


public int[] minHeap(int[] denominations,int max){
	int res[]=new int[deno.length];

	for(int i=0;i<deno.length-1;i++) {
			res[i]=deno[i+1]-deno[i];
	}

	res[deno.length-1]=max/deno[deno.length-1];

	return res;
}
Is that correct? Let me know.

google
india
phone screen
Comments: 10

https://leetcode.com/discuss/interview-question/5631366/My-Google-Interview-Experience%3A-A-Journey-of-7-Interviews-and-Rejection


https://leetcode.com/discuss/interview-question/2257966/Google-OA
Google OA
43
Anonymous User
Anonymous User
July 9, 2022 3:09 PM

4.3K VIEWS

Partition String
You are given a string S of lenght N of digits 0 - 9. You need to partiton strings into K substrings such that


Each substring has a minimum lenght of M
Substring must start with even digit and ends with odd digit number
Determine the number of ways to partitioin the strings which satisfy the above condition
You should find answer modulo 1e9 + 7


constraints :
1 <= n<= 2x10^3
1<= m<= n
1<=k<=n


Test cases


n = 9 
m= 2
k = 3
s = '232387421'
So there are total 3 ways possible

https://leetcode.com/discuss/interview-question/2218210/Google-or-Phone-Screening-Round-or-45-Mins-or-New-Grad
Google | Phone Screening Round | 45 Mins | New Grad
5
Anonymous User
Anonymous User
Last Edit: June 30, 2022 5:24 PM

952 VIEWS

Two coding questions.


https://leetcode.com/problems/happy-number/ happy number is a number defined by the following process:
Starting with any positive integer, replace the number by the sum of the squares of its digits.
Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
Those numbers for which this process ends in 1 are happy.
Return true if n is a happy number, and false if not.


Given an array (0 index based) , count the pairs who can satisfy the following condition :- A[i]-A[j] = j-i
ex = [1,3,3,2,1]
output - 3


google
india
new graduate
Comments: 5
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
imdreamer's avatar
imdreamer

17
Last Edit: June 30, 2022 8:03 PM

Read More
I think for the 2nd problem..
it is basically asking find the pairs where A[i]+i == A[j]+j
you can store the sum Frequency in a map..
like map[nums[i]+i]++;
and whenever you find nums[j]+j already exist in the map then you are sure that some map[nums[i]+i] times indexes exist for this j to pair.. then you increment the map[nums[i]+i]++
so that when the next nums[k]+k comes it can also pair with those number...
this way we can solve it in O(n) Time and O(n) Space..
Do let me know if this solution doesn't work..
Thanks

8
Reply
Share
Report
siddharth_13's avatar
Siddharth Yadav

62
Last Edit: July 1, 2022 9:34 AM

Read More
Second problem translates to, calculate numbers with A[i]+i = A[j]+j. Take an unorderedMap to store count. Calculate for A[i]+i for for each index, update the value count in map, then do value*(value-1)/2 for each key in the map, given it's value is greater than 1.

1
Show 1 reply
Reply
Share
Report
grawlixes's avatar
grawlixes

5565
July 1, 2022 9:11 PM
https://leetcode.com/discuss/interview-question/2209335/Google-Intern-OA-or-India


Google Intern OA | India
16
Anonymous User
Anonymous User
June 28, 2022 4:41 PM

2.1K VIEWS

Position: SWE Intern
Place: India


Time: 60 minutes
Max. Score: 60 points (30 points / problem)


Note
Following are the question I have got in my Online Assessment test that was conducted on Hackerearth platform couple of days back. I have tried my best to format well the problem statements, Hope it helps you! Happy Coding :)

Problem 1: Existence of a Path
You are given a weighted undirected graph G that contains N nodes and M edges. Each edge has a weight associated to it.


You are required to answere Q queries of the following type:


x y W : Find if there exists a path in G between nodes x and y such that the weight of each edge in the path is at most w. If such path exists , then print 1. Otherwise, print 0.
Input Format


The first line contains an integer T denoting the number of test cases. For each test case :-
The first line of each test case contains three space separated integers N, M, Q.
Next M lines of each test case contains three space separated integers u, v, and w denoting an edge between node u and v with weight w.
Next Q lines of each test case contains three space separated integers x, y, and W denoting the queries.
Output Format


For each test case, print Q lines denoting the answer to respective queries.


Constraints


1 ≤ T ≤ 5
1 ≤ N, Q, M ≤ 105
1 ≤ w, W ≤ 105
1 ≤ x, y ≤ N


Example 1:
Example 2:
Input: 
1
8 4 3
8 8 67
2 3 85
3 6 97
7 5 44
5 2 86
8 5 47
5 5 63

Output:
0
0
1
Example 3:
Input: 
1
5 1 4
3 5 51
4 5 71
2 3 91
4 4 61
3 1 8

Output:
0
0
1
0
Example 4:
Input: 
1
5 4 2
1 4 30
2 4 50
5 1 77
3 4 74
1 4 26
1 3 10

Output:
0
0

Problem 2: The maximum XOR value
You are given an array consisting of N integers. You are given q queries. Each query has two integers x and m. For each query, you are required to determine the array value that provides the maximum bitwise XOR value with x where the array value is not more than m.


In other words, for each query, you must find arri (1 ≤ i ≤ n, arri ≤ m) such that the value of (x ⊕ arri) is maximum where ⊕ denotes the bitwise XOR operator. If there is no such value that satisfies the condition, then print -1.


Input Format


The first line contains an integer T denoting the number of test cases.
The first line of each test case contains an integer N denoting the number of elements in the array.
The second line of each test case contains N space-separated integers denoting arr1, arr2, arr3 . . . , arrN .
The third line of each test case contains an integer q denoting the number of queries.
Next q lines contain two integers x and m denoting the ith query.
Output Format


For each test case, print q lines denoting the required answer.


Constraints


1 ≤ T ≤ 5
1 ≤ N, q ≤ 105
0 ≤ arri, x, m ≤ 109


Example 1:
Input: 
1
7
3 7 19 18 7 12 17
7
3 8
21 20
24 17
1 7
23 17
12 9
99 2

Output:
7
12
7
7
12
3
-1

Explanation:
In the first query x = 3 and m = 8. There are three values in the array that are not more than 8 (3, 7, 7). Therefore, XORs of these values are (3 ⊕ 3) 0 and (3 ⊕ 7) 4. The answer is 7.

In last query, all the values of the array are greater than 2. The answer is -1.
Inventory of Past Google Online Assessment Problem Statements
https://leetcode.com/discuss/interview-question/2204105/Google-Interview-Questions
Google Interview Questions
3
Anonymous User
Anonymous User
Last Edit: June 27, 2022 1:30 PM

424 VIEWS

I have been asked these two questions in two rounds. Both of them are DSA/Coding/Algorithmic questions:


You need to design a booking system for a meeting room. For each entry, you will be given a start time and end time. You have a function
called booking() that will return a true or a false for every query based on whether or not the room is available.
Note that the data will be in a stream i.e. real-time, future booking values are not known to you.


You need to give stock information based on some parameters. The system will be giving you real-time data (future timestamps/prices are not known) in form of a timestamp, price throughout the day, and timestamp order can be random (not necessarily sorted).
Also, the stock prices can alter the already entered timestamps in three ways:


Delete an entry at given timestamp
Add a new entry
Change the price of stock at a given timestamp
Now for each query, you need to return:


Price of stock at latest timestamp
Maximum stock price so far
Minumum stock price so far
PS: I did not answer either of thw two with completely optimal solutions, it was rather in the midway between brute force and optimal. Hence
any leads to solve these sort of dynamic update queries would be appreciated.

google
india
interview questions
google-interview
google-virtual-onsite
Comments: 4

https://leetcode.com/discuss/interview-question/2199394/Google-or-Phone-or-Time-for-turn
Google | Phone | Time for turn
20
Anonymous User
Anonymous User
Last Edit: June 26, 2022 1:15 PM

4.1K VIEWS

Problem description
Joseph is standing at k+1th position in a queue at an insurance company's office and there are n counters at the office, ith counter takes time[i] time (minutes) to process a request. The security guard assigns a counter to the person standing in the front of the queue as soon as a counter is available or if multiple counters are available, then the security official assigns the counter with minimum id (consider id as index). What would be the time at which Joseph's request would be processed aka the ending time when Joseph leaves the office?


Example case


n = 3
times = [3,2,5]
k = 4

Person 1: assign counter 0 (available counter with minimum index)
Person 2: assign counter 1 (available counter with minimum index)
Person 3: assign counter 2 (available counter with minimum index)
Person 4: assign counter 1 (available counter with minimum index)
Person 5 (Joesph): assign counter 0 (available counter with minimum index)
Solution proposed


Maintain ending times for each counter in a priority-queue (min heap)
Initially add n counters to the queue with ending time as 0
Custom comparator function to handle counters with same ending times (choose the one with minimum index)
Iterate for each person in the queue for k positions:
Pick the counter to be assigned from the heap and re-insert it with updated end-time
Fetch the top most element from the heap and answer would be endTime + time taken to process request for that counter
Interview Experience Post: https://leetcode.com/discuss/interview-question/2199510/Google-or-L4-or-India-or-June-2022-or-Accepted

google
india
bangalore
startup
onsite 2022
Comments: 9
BestMost VotesNewest to OldestOldest to Newest
https://leetcode.com/discuss/interview-question/2199393/Google-or-Onsite-or-Flow-water-to-cities
Google | Onsite | Flow water to cities
8
Anonymous User
Anonymous User
Last Edit: June 26, 2022 1:15 PM

3.1K VIEWS

Problem description
You're given a grid where each cell grid[r][c] represent city height, overall country (grid) is surrounded by an ocean. You're also given coordinates of two cities c1 and c2, find out the city with minimum height from where we can shower water such that it can reach to the given two cities.
Water can only flow from a city with height h1 to city with height h2 iff h1 >= h2.


Solution proposed


Iterate through each cell of the grid
Initiate two depth-first searches starting from current cell passing the target coodinate info
To improve this, memoise the DFS function so that each cell is visited at-max 2 times
Memoisation can only work if you define separate caches for each given target coorindate
Follow-up
Instead of returning city with minimum height, return city from which water can reach both cities the fastest.


Solution proposed


Instead of iterating through each cell, run breadth first search simultaneously expanding from both cities
Maintain two visited hashsets and as soon as you find an intersecting coordinate, return it as answer (first cell in BFS = shortest distance from both cities)
Interview Experience Post: https://leetcode.com/discuss/interview-question/2199510/Google-or-L4-or-India-or-June-2022-or-Accepted

google
india
bangalore
startup
onsite 2022
https://leetcode.com/discuss/interview-question/2199392/Google-or-Onsite-or-Generic-language-translator
Google | Onsite | Generic language translator
19
Anonymous User
Anonymous User
Last Edit: June 26, 2022 1:15 PM

4.2K VIEWS

Problem Description (warm-up)
Implement the methods of the class:


class EnglishSpanishTranslator {
public:

	// adds a bi-directional mapping between these words to the knowledge base
	void addTranslation(string englishWord, string spanishWord);

	// gets english for a spanish word else raise an exception
	void getEnglish(string spanishWord);

	// gets spanish for an english word else raise an exception
	void getSpanish(string englishWord);
};
Straightfoward Solution
Use two hashmaps (unordered_map) to keep the relations and return the translations.


Problem description (core)
Implement a generic translator class where you can add translations from any language to any other languge to the knowledge base and can query the same way. It should allow multi-level translations.
Multi-level translations: If there's a word translation in the knowledgebase for English <-> Spanish and Spanish <-> Hindi, when queried for Hindi -> English for the same word, function should still be able to return it if there's an indirect relation.


Solution


Instead of maintaining two hashmaps, maintain a graph
define each node having a word and it's language
edges represent relation between these words
Maintain a mapping to fetch the node having word-language combination in constant time
define key as word:language and value as node pointers
Run a DFS from starting node (node with the right word/lang combination) to find out the resultant node and return the translation
Interview Experience Post: https://leetcode.com/discuss/interview-question/2199510/Google-or-L4-or-India-or-June-2022-or-Accepted

google
india
bangalore
startup
onsite 2022
https://leetcode.com/discuss/interview-question/2186370/Google-Onsite-or-L4-or-India
ack
Google Onsite | L4 | India
15
Anonymous User
Anonymous User
June 23, 2022 12:59 PM

2.6K VIEWS

Round 1-

There is a matrix given and it has values 0(water) and 1(land).
there are islands and ocean. There are lakes between the islands. 
Given a point of a island, return the number of lakes in it.


Round 2-
There are 3 color (RGB) cards , each of number 1-9.
You are given a hand of 12 cards, find if it would be a winning hand or not?

for winning hand, it should make 4 patterns.
Pattern can be 2 types -
A) 3 cards of same color and same number
B) 3 cards of same color and consecutive number

Example -
R5, R5, R5 -> is a pattern
G1, G2, G3 -> is a pattern
B1, B2, B4 -> not a pattern
google
india
l4
google interview question
Comments: 13
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
Kaushal349's avatar
Kaushal Aggarwal
13
Last Edit: June 23, 2022 4:11 PM

Read More
Algo for Q1
We need to define the island
           Run dfs from given point and travel to cell only if it is 1 and mark them as part of given island

With that boundary look for 0 and count the cluster of that 0
           Travel the matrix if 0 is found we can start DFS.
           A cluster lies within the given island only and only if every 0 of that cluster satisfies the below 2 conditions–
                    It should be on the edge of matrix
                    It should not connect to any other island except the given island
           if the cluster satisfies the above conditions we increment our lake count.
  
Space complexity- O(n*m) where n is the number of rows and m is the number of cols of the matrix
Because we need to keep a matrix to mark if a cell was a part of a given island or not, we need to maintain if we have already visited a water cell or not!

Time complexity - O(n*m)where n is the number of rows and m is the number of cols of the matrix
Because we will need to visit every cell in the worst case.

6
Reply
Share
Report
Kaushal349's avatar
Kaushal Aggarwal
13
June 23, 2022 4:10 PM

Read More
Simplify the ques– 
Every card will contribute to winning hand, it can do it in 2 ways
Either by following pattern1 or pattern 2
We have 2 choices for each card to put it in pattern 1 or pattern 2
2^12 makes sense too when looking at the constraints…

High Level Algo

Keep 2 sets of strings, one for pattern1 and second for pattern 2
Every card has 2 options to go to wither set1 or set2
When every card is placed in one of the 2 sets, check if it’s a winning hand

Code–

Class Solution{
	Private:
	vector<string> pattern1, pattern2;

Bool checkWinningPattern(){
	if(pattern1 % 3 !=0) return false;
	// if pattern1 is a multiple of 3, we are sure
	// that pattern2 is a multiple of 3
	for(int i=0;i<pattern1.size();i+=3){
		for(int j=i;j<i+3;j++){
			if(pattern[j][0] != pattern[j][0]) 
return false;
if(pattern[j][1] - pattern[i][1] != j-i)
	Return false;
		}
	}
for(int i=0;i<pattern2.size();i+=3){
		for(int j=i;j<i+3;j++){
			if(pattern[j][0] != pattern[j][0]) 
return false;
if(pattern[j][1] != pattern[j][1]) 
	Return false;
		}
	}
	Return true;
}	

	Bool canWinByCards(vector<string> &cards, int onIndex){
		if(onIndex == cards.size()){
			Return checkWinningPattern();
		}
		pattern1.push_back(cards[onIndex]);
		Bool won = canWinByCards(cards, onIndex+1);
		pattern1.pop_back();
		
if(won) return true;		
		
		pattern2.push_back(cards[onIndex]);
won = canWinByCards(cards, onIndex+1);
		pattern2.pop_back();

		Return won;
}
	Public:
		Bool isWinningHand(vector<string> &cards){
			pattern1.clear();
			pattern2.clear();
			sort(cards.begin(), cards.end());
		Return canWinByshuffle(cards, 0);
		}
};

Time complexity– 2^n, here n is 12, number of cards,
We can ignore sorting time complexity which is nlogn

Space complexity– 2^n due to number of possible options which increases stack calls
We can ignore vector for 2 patterns which are of n length
4
Show 4 replies
Reply
Share
Report
venompool's avatar
Rahul

82
June 23, 2022 1:35 PM

Read More
For the first question, from that point on island, run a dfs. Everytime you get a water cell i.e 0 which is yet not visited, do a counter++, start a bfs/dfs from it and mark all the water cells connected to it.
At the end of this, counter will have number of lakes+1(for ocean) . Return counter-1 as answer.

4
Show 10 replies
Reply
Share
Report
AjayChowdhary's avatar
AJAY CHOWDHARY

3
Last Edit: June 24, 2022 4:44 PM

Read More
For question 2.


use count-sort since the num is between 1-9 for each color: this will form the following table.


1 2 3 4 5 6 7 8 9
R.
G
B


Now iterate over each color - row .
Case 1 : cell contains > 2 elements (count++) (Pattern A)
Case 2 : 3 consecutive eles. in a row has > 0 values (count++) (Pattern B)
at last if count is greater than 3 return true;

2
Show 1 reply
Reply
Share
Report
huangshan01's avatar
Shan

341
Last Edit: June 23, 2022 11:27 PM

Read More
DSU should work:


Union the land starting the point given, and track water touching this land.
Traverse the water cells tracked, DFS or BFS to union them or fill them with soil, e.g. label them 2. If during landfilling, a water cell touches an alien land cell that has not been unioned during step 1, it means that the water being filled is not an inner lake. Finish the landfill, increase the count if an inner lake.

https://leetcode.com/discuss/interview-question/2162295/Google-Interviews-In-progress

https://leetcode.com/discuss/interview-question/2104997/Google-or-Interview-Experience-or-SE-Full-Stack-or-Virtual-Interview

Google | Interview Experience | SE - Full Stack | Virtual Interview
6
Anonymous User
Anonymous User
Last Edit: June 5, 2022 10:44 PM

1.2K VIEWS

Hello,


I recently had an opportunity to appear for interviews at Google, India for SE - Full Stack Developer role. The position was for experienced professionals. The interviews were conducted over Google Meet and each interview on a separate day. (You can discuss this with your recruiter how you want the interviews to be conducted, all on a single day or on separate days ).


Following are the interview rounds that were conducted.
Round 1, 2, 3 - Technical, only Coding no Design rounds. ( ~ 45 mins each)
Round 4 - Behavioural. ( 45 mins )


Round 1:
Given a grid n x m consisting of 0's and 1's, where 0 respresents a free cell and 1 represents a wall. If a robot is placed at first cell, i.e. position (0,0), find whether it can reach the end cell i.e. (n-1, m-1), by breaking at the most one wall in the grid.


Round 2:
This was based on OS job scheduling, and it was mostly open-ended question. I was not provided of how the input will be, these were the points that were to be discussed with interviewer.


Given a list of jobs, with their arrival time and execution time, return the sequence of execution and the starting time of each job, on a First Come First Serve(FCFS) basis.
Follow up question: If priority is associated with each job, how will the algo change in that case.


Round 3:
Given a n-ary tree, and 2 edges represented by the vertices connecting them (V1, V2) and (V3, V4). Return the number of vertices (nodes) in each disconnected component, if these 2 edges are removed from the tree, basically if the tree was disconnected. Given Q queries, return the result for each query, assuming tree is fully-connected each time.


Round 4:
Mostly all the questions were situation-based, like tell me about a time..., along with follow-up questions.

google
india
interview-experience
experienced
google-interview
virtual-interview
Comments: 4
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
ironfist's avatar
Prakhar

97
June 5, 2022 2:03 AM

Read More
Round1: In case the robot is allowed to go down and right only then I think, just finding the min-sum from 0,0 to n-1,m-1 and checking if it is less than equal to 1 should solve the problem. If the robot is allowed to go in all 4 directions, then I guess we can do it by backtracking+memoization.


Round2: If I understand the question correctly, the input is like [1,4], [6,3], [2,1] where the first value is arrival time and the second value is how much time it will take for the job to finish. First part can be solved by first sorting the jobs by arrival time and then simply maintaining a time variable and incrementing it by execution time. e.g. ans will be 0, 4, 6. The second part can be solved by sorting the array by priority and then scheduling the jobs.


Round3: we can use uncompressed union-find here basically we need to build a tree from the given tree where each node stores the index, its parent, and the size of its subtree. From there onwards its trivial.


PS The solutions are as per my understanding of the questions and I might be wrong.

3
Show 1 reply
Reply
Share
Report
sahilgoel1610's avatar
sahilgoel1610

15
June 17, 2022 4:07 PM

Read More
Round1: an easier variation of https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination with k = 1. Implementation using the BFS approach can remain same.

1
Reply
Share
Report
gloom007's avatar
Saurabh Singh

91
June 3, 2022 11:32 AM

Read More
Can you pls share your round-wise interview feedback also?

1
Reply
Share
Report
nnkitsaini's avatar
Ankit Saini

71
June 3, 2022 9:25 PM

Read More
Can you please how did you land the interview? were you contacted by recruiter or did you get a referral. In my particular case I think I'm well prepared to give the interviews, but not able to land one. I've tried contacting recruiters and also tried applying through a referral with no luck.

0
Show 4 replies
Reply
Share
Report

https://leetcode.com/discuss/interview-question/2076033/Google-or-Telephonic-interview-question

Google | Telephonic interview question
3
Anonymous User
Anonymous User
Last Edit: May 27, 2022 3:39 PM

670 VIEWS

Given 2 strings A and B


[Edited]
A-> aacbbabc
B->aaaabbc
Output->2 //For some reason I remember 4 lol
Calculate the minimum number of steps required to create string B using subsequences of A
Eg: aaaabbc--> aaa(bec there are 3 subsequences as in A at max), abbc


I was not able to provide an optimized approach only a greedy approach.

google
india
screen-round
Comments: 6
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
mert48's avatar
mert

43
May 26, 2022 7:25 PM

Read More
Looks like this one: https://leetcode.com/problems/shortest-way-to-form-string/

7
Reply
Share
Report
Achal_Jain's avatar
Achal Jain

12
May 6, 2024 9:27 AM

Read More
A simple greedy match should suffice.
Another optimization that can be done is we can store the indexes of each character and then do binary search for the just next greater index for a particular character.
This should change the time complexity to O(nlgn) from the O(n^2) solution below.


int solve(string&source, string&target) {
	int n = source.length();
	int m = target.length();
	int cnt = 0;
	for (int i = 0; i<m; ) {
		int j = 0;
		int k = i;
		bool match = false;
		while (j < n && k < m) {
			if (source[j] == target[k]){
				match = true;
				++j;
				++k;
			} else {
				++j;
			}
		}
		if (!match)return -1;
		++cnt;
		i = k;
	}
	
	return cnt;
}
0
Reply
Share
Report
shubham20041998's avatar
Shubham Gupta

1
June 3, 2022 2:13 AM

Read More
If we calculate the Longest common subsequence of A and B and subtract it from the length of B, will it work?
I am not sure, just a thought, please let me know.

0
Reply
Share
Report
akash3anup's avatar
Akash Anup

1120
June 1, 2022 12:09 AM

Read More
Simple Solution
class Solution:

    def longestSubsequence(self, source, target, targetIdx):
        targetStartIdx = targetIdx
        sourceIdx = 0
        while sourceIdx < len(source) and targetIdx < len(target):
            if source[sourceIdx] == target[targetIdx]:
                targetIdx += 1
            sourceIdx += 1
        if targetIdx == targetStartIdx:
            return -1
        return targetIdx

    def shortestWay(self, source: str, target: str) -> int:
        steps = 0
        targetIdx = 0
        while targetIdx < len(target):
            targetIdx = self.longestSubsequence(source, target, targetIdx)
            if targetIdx < 0:
                return -1
            steps += 1
        return steps


print(Solution().shortestWay(source="abc", target="abcbc"))  # 2
print(Solution().shortestWay(source="abc", target="acdbc"))  # -1
print(Solution().shortestWay(source="xyz", target="xzyxz"))  # 3

0
Reply
Share
Report
aksingh5's avatar
aksingh5

0
May 27, 2022 1:52 AM

Read More
Could be done by tracking the char locations.


class Solution {
    public int shortestWay(String source, String target) {
        Map<Character, List<Integer>> map = new HashMap();
        
        for (int i = 0; i < source.length(); i++) {
            char c = source.charAt(i);
            
            if (map.get(c) == null) {
                map.put(c, new ArrayList());
            }
            
            map.get(c).add(i);
        }
        
        int count = 1;
        int last = -1;
        for (char c : target.toCharArray()) {
            if (map.get(c) == null) {
                return -1;
            }
            
            List<Integer> locs = map.get(c);
            
            if (locs.get(locs.size()-1) <= last) {
                count++;
                last = locs.get(0);
            } else {
                for (int i : map.get(c)) {
                    if (i > last) {
                        last = i;
                        break;
                    }
                }
            }
        }
        
        return count;
    }
}
0
Reply
Share
Report
user7076F's avatar
Saeyoung

35
May 26, 2022 7:14 PM

Read More
from above example, I think the answer is 2 (aaa , abbc from subsequences of A). is it right?

0
Show 2 replies
Reply
Share
Report

https://leetcode.com/discuss/interview-question/2071924/Google-or-L4-or-India-or-May'22-Reject
Google | L4 | India | May'22 [Reject]
8
Anonymous User
Anonymous User
May 25, 2022 12:30 PM

1.3K VIEWS

Status: 2 YOE, Tier 1 College
Position: SDE1 at a Startup
Location: India
Date: 1st March, 2022


Previous Experience:


Rejected by Google in Technical Phone Screen Round for the last two years.
Codeforces: Expert. Have solved around 400 problems there.
Leetcode: E-51 M-93 H-36
I don't get enough time to practice because my current job takes around 10 hours everyday.
Note: All the rounds were of 45 minutes.


Technical Phone Screen: Algorithm question(Level - Medium). Standard DP. Interviewer asked some of the corner cases. I was able to write the DP but unable to give reason for corner cases. Interviewer was okay.


Feedback was positive, so the interviewer scheduled 3 Virtual Onsite rounds and told they will schedule 2 more rounds if the feedback will be positive.


Onsite Round 1: Logical Problem Solving (Level - Hard). I wrote the brute force approach and the interviewer said to optimize it. I could not do it in the time frame, tried a few approach, but those came out to be worse than brute force in terms of ensuring it will always give the correct answer. I told that this approach is not good.


Interviewer was nice. Two minutes after the interview, I thought of the efficient approach. Interview pressure fucked up this round.


Onsite Round 2: Algorithmic Problem (Level - Hard). It was an open ended problem and I have to think of solutions to solve it. I explained my approach to the interviewer, but he did not seem convinced to my solution. So I thought of 2-3 more approaches, but then he did not seem convinced either. Then towards the end of the interview, he said my first approach was correct and he was expecting me to go forward on that one.


Interviewer seemed busy in something else and wasn't replying on time to my appraoches.


Onsite Round 3: Algorithmic Problem (Level - Hard). I told the effecient approach in one go and explained all the edge cases and wrote the code. Interviewer was convinced and we finished before time.


Interviewer was nice.


Result: Reject and not getting considered for the further rounds.


Feedback: Need to come up with solutions faster.


Learnings:


Try to take less pressure in the interview.
Need to practice more to be able to come up with solutions faster.
I hope these learnings help someone else get into your dream company. I gave some dummy interviews to reduce the pressure but it still happened. Now, the coolback period is 1 year and I will try again next year.

google
india
Comments: 4
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
prakashshukla1820's avatar
Prakash Shukla

9
June 24, 2022 2:48 AM

Read More
Keep your practice going and try mocks

1
Reply
Share
Report
RoberParadigm's avatar
RoberParadigm

3
May 26, 2022 9:07 PM

Read More
3 hards, where will be go? This is nearby impossible if you are not a freak without life

1
Show 1 reply
Reply
Share
Report
HeyWarriorKeepGoing's avatar
Warrior

69
May 25, 2022 2:00 PM

Read More
can you share the questions or similar questions to leetcode

1
Show 1 reply
Reply
Share
Report
aspi98's avatar
Priyanka Roy Chowdhury
10
May 26, 2022 10:29 PM

Read More
Is the coolback period 1yr really? wasn't it 6months?

0
Show 1 reply
Reply
Share
Repor

https://leetcode.com/discuss/interview-question/2069303/Asked-in-Google
Asked in Google
5
Anonymous User
Anonymous User
Last Edit: May 24, 2022 3:57 PM

2.2K VIEWS

There is one question that is just asked As I remember only a few part of the question if someone can help


N=4
[4,10][7,13][20,30][1,40]--> 6,3,10,20
[4,10]->10-4= paint 6
[7-13]->13-10=paint 3
[20,30]->30-20 paint 10
[1,40]->20
If someone can provide a solution asap! I was thinking to merge the overlapping interval and keep in stack and everytime a new element is visited I will check the top of the stack and then make a conclusion. Again I am not sure the exact approach.

google
india
google step
Comments: 9
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
Octavius25's avatar
Abhinav Pandey

86
Last Edit: October 22, 2022 6:10 AM

Read More
HI I got this approach even though not optimized but still it can be an easy approach to think TC : o(n^2)


import java.util.HashMap;

public class GoogleIInterviewLeet {
	static int[] painting(int paint[][] ) {
		HashMap<Integer,Integer>h=new HashMap<>();
		int ans[]=new int[paint.length];
	
		for(int i=0;i<paint.length;i++) {
			int work=0;
			int st=paint[i][0];
			int ed=paint[i][1];
			while(st<ed) {
				if(!h.containsKey(st)) {
					h.put(st,ed);
					work++;
				}
				else {
					st=h.get(st);
					continue;
				}
				st++;
			}
			ans[i]=work;
		}
		return ans;
	}
	public static void main(String[] args) {
		int ar[][]= {{4,10},{7,13},{20,30},{1,40}};
		int ans[]=painting(ar);
		for(int v:ans)System.out.println(v+" ");
	}
}
0
Reply
Share
Report
big-whoop's avatar
big-whoop

563
August 24, 2022 9:41 PM

Read More
Hello there, did you get this Question during phone screen? or On-site? Thanks.

0
Reply
Share
Report
c0D3M's avatar
c0D3M

2017
July 6, 2022 10:29 PM

Read More
Line Sweep is getting asked frequently, written a post about problem on this pattern
https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms

0
Reply
Share
Report
madhudulam's avatar
Madhu Kumar Dulam
12
July 6, 2022 9:19 PM

Read More
#Array, Segment Tree, Ordered Set
from sortedcontainers import SortedList
from typing import List


class Solution:
def amountPainted(self, paint: List[List[int]]) -> List[int]:
minDay = min(s for s, e in paint)
maxDay = max(e for s, e in paint)
ans = [0] * len(paint)
# store indices of paint that are available now
runningIndices = SortedList()
events = [] # (day, index, type)


for i, (start, end) in enumerate(paint):
  events.append((start, i, 1))  # 1 := entering
  events.append((end, i, -1))  # -1 := leaving

events.sort()

i = 0  # events' index
for day in range(minDay, maxDay):
  while i < len(events) and events[i][0] == day:
    day, index, type = events[i]
    if type == 1:
      runningIndices.add(index)
    else:
      runningIndices.remove(index)
    i += 1
  if runningIndices:
    ans[runningIndices[0]] += 1

return ans
#Time: O(max⁡(paint[i][0])+nlog⁡n)


Space: O(n)
Reference from here: https://walkccc.me/LeetCode/problems/2158/

0
Reply
Share
Report
user9247J's avatar
user9247J

164
July 2, 2022 9:14 PM

Read More
Using merge intervals concept it can be solved, push each interval and merge them, calculate total Paint - total painted yet.
However time complexity is O(N^2LogN) which is not optimal I suppose.


int mergeIntervals(vector <vector <int>> &intervals)
{
    sort(intervals.begin(), intervals.end());
    vector <vector <int>> mergedIntervals;
    int totalPaint = 0;
    for(auto i : intervals)
    {
        if(mergedIntervals.empty() || mergedIntervals.back()[1] < i[0])
        {
            mergedIntervals.push_back(i);
        }
        else
        {
            mergedIntervals.back()[1] = max(mergedIntervals.back()[1], i[1]);
        }
    }
    for(auto i : mergedIntervals)
        totalPaint += abs(i[0] - i[1]);
    return totalPaint;
}
int main() {
    std::cout << "Hello World!\n";
    vector <vector <int>> area = {{4, 10}, {7, 13}, {20, 30}};
    vector <vector <int>> res;
    
    res.push_back(area[0]);
    int paint = area[0][1] - area[0][0];
    
    vector <int> ans; 
    ans.push_back(paint);
    for(int i = 1; i < area.size();i++)
    {
        // push each interval and merge it with the already processed ones.
        res.push_back(area[i]);
        int totalPainted = mergeIntervals(res);
        ans.push_back(totalPainted - paint);
        paint = totalPainted;
    }
    for(auto i : ans)
        cout<<i<<" ";
    cout<<endl;
}
// O (N^2 Log N)
// Given a horizontal line, you have to paint coordinates and tell the amount of paint required at every step.
// Ex - [(4, 10), (7, 13), (20, 30)]
// ans - [6, 3, 10]
0
Reply
Share
Report
Guddu_pandit's avatar
Guddu_pandit

15
June 11, 2022 11:23 AM

Read More
use brute fore, with just one caveat keep merging the segments while you move from left to right

0
Reply
Share
Report
c0D3M's avatar
c0D3M

2017
May 25, 2022 10:20 AM

Read More
Lets see with an example"
Current painted area are [1, 4] [ 5, 8] [10, 20]
Keep a sorted map which store 1->4, 5->8
Newly added is [4, 21]


First do a upper bound on start indx i.e. 4 , now here there can be 2 possibility of previous of upper_bound
Either new_start <= prev->second (like here prev = [1,4] , new_start 4 >= 4]
Or we have a new interval altogether (for example if existing area is [1, 4] , and you try to paint [5, 8]. 5 > prev->second , so [5, 8] added as new area)
Now see this new area is eclipsing how many existing area in right hand side , this has to be done in while loop as long as new _index end is


for example in the example stated above [4, 21] area will eclipse [5,8] and also [10, 20] , there are already painted area, so they need to be subtracted,
until 21 > 5 and 21 > 10 and next!= end
0
Reply
Share
Report
Anonymous User
Anonymous User
May 24, 2022 5:07 PM

Read More
This is not the free version https://leetcode.com/problems/amount-of-new-area-painted-each-day/ :(

0
Show 2 replies
Reply
Share
Report
agnii's avatar
Agnieszka

28
May 24, 2022 4:37 PM

Read More
https://leetcode.com/problems/amount-of-new-area-painted-each-day/

0
Reply
Share
Report

https://leetcode.com/discuss/interview-question/2056758/Google-or-Phone-Interview-or-If-Circles-are-from-single-circle-group
Google | Phone Interview | If Circles are from single circle group
17
pranikp's avatar
Pyusha
21
Last Edit: May 20, 2022 4:06 PM

3.0K VIEWS

you are given a list of circles with there center coordinates and radius, return true if the given circles belong to a single corcle group else return false.


Example -
input :
[(x0,y0,r0),(x1,y1,r1)]


[(1,2,4),(3,7,5),(2,2,4)]


output: false

google
india
screening
Comments: 10
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
flitt's avatar
flitt

6
Last Edit: May 21, 2022 2:46 AM

Read More
If "circle group" means that all the circles of the group are inscribed in one circle, then the problem can be rephrase as "Given a list of circles, find if there is a circle A in the list such that all circles except A are inscribed in A".
To solve this problem I would:


initially find a circle Ai with the largest radius Ri.
then for each circle Aj where j !=i we should check if the Aj is inscribed in Ai. It does if
distance(Ci, Cj) <= Ri - Rj,
where C - center point of circle,
R - radius value.
distance can be evaluated as sqrt((Xi-Xj)^2 + (Yi-Yj)^2)
the result is true if all Aj is inscribed in Ai
Totally will have to do 2 loops over the list of circles - it means algorithm has linear complexity O(n).


P.S.
formula can be overwritten as (Xi -Xj)^2 + (Yi-Yj)^2 <= (Ri - Rj)^2

6
Show 2 replies
Reply
Share
Report
Anupreet009's avatar
Anupreet Kaur

3
May 24, 2022 12:51 AM

Read More
A single circle group means there is an overlapping in any of the 2 circles. If all the circles are overlapped with each other that means it forms a single circle group, so we should return true. If there is a circle which does not have an overlapping with any circle, that means it is not a circle group, so we should return false. So, now the problem simply converts to "isConnectedComponent". Each circle is a node in the graph and edges will tell us if there is an overlapping or not. Create a graph from the circles given and perform dfs on the graph. Count the circles you see while performing dfs and in the end compare the count with the number of circles initially present. If it's equal, return true, else return false.

3
Show 1 reply
Reply
Share
Report
anchalgupta2412's avatar
anchalgupta2412
1
Last Edit: November 24, 2022 1:55 PM

Read More
A single circle group means there is an overlapping in any of the 2 circles. If all the circles are overlapped with each other that means it forms a single circle group, so we should return true.
*Take each pair of circle using O(n^2)


Make adjacency matrix where for each circle appends the other circle based on following:
adjMatrix = {}
for c1 in list:
for c2 in list:
if distance(c1,c2) <= R1+R2: # distance euclidean distance between 2 points (sqrt(x1-x2)**2 + sqrt(y1-y2)**2)
-> Check if c1 exists in adjMatrix else create it
adjMatrix[c1].append(c2)


You will get something like this for above input: [(1,2,4),(3,7,5),(2,2,4)]
{0: [1, 2], 1: [0, 2], 2: [0, 1]} ->
meaning :
c1 intersects with c2 & c3,
c2 intersects with c1 & c3
c3 intersects with c1 & c2


Then traverse through above matrix like graph & find if all circles are covered in deepest path using DFS


P.S: Answer to given input should be True

1
Reply
Share
Report
ecdrid's avatar
Aditya

274
August 13, 2022 6:11 PM

Read More
This would be a union-find / connected components problem. If you imagine each circle in the list as a node in a graph, where an edge exists between two nodes if the distance between two circles minus the sum of the radii is less than or equal to zero, then you could build an adjacency list / matrix between all circles and the circles that overlap with it. Then perform a single DFS / BFS, and if the number of nodes visited equals the number of circles in the list, then it must be a single circle graph because you were able to visit every circle from any node in the graph.

1
Show 14 replies
Reply
Share
Report
ulyx's avatar
ulyx

75
April 10, 2024 6:10 AM

Read More
find the largest circle (with largest redius), check the distance between it's center with other centers, if the distance less than the difference of their radius, it's in the big circle.

0
Reply
Share
Report
divakar1669's avatar
Divakar Thiyagarajen

62
February 4, 2024 2:42 PM

Read More
//$Id$
package LeetCode_I;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;


class Circle {
int x, y, radius;


public Circle(int x, int y, int radius) {
	super();
	this.x = x;
	this.y = y;
	this.radius = radius;
}

public boolean isOverlap(Circle other) {
	int distanceSquared = (x - other.x) * (x - other.x) + (y - other.y) * (y - other.y);
	int radiusSumSquared = (radius + other.radius) * (radius + other.radius);
	return distanceSquared <= radiusSumSquared;
}
}


public class CirclesBelongToSameComponenet {


public boolean circleOfSameComponet(List<Circle> list) {

	int n = list.size();
	int parent[] = new int[n];
	Arrays.fill(parent, -1);

	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (i != j && list.get(i).isOverlap(list.get(j))) {
				int iParent = findParent(i, parent);
				int jParent = findParent(j, parent);
				if (iParent != jParent) {
					parent[iParent] = jParent;
				}
			}
		}
	}
	int count = 0;
	for (int i = 0; i < n; i++) {
		if (parent[i] == -1) {
			count++;
		}
		if (count > 1)
			return false;
	}
	return true;

}

private int findParent(int i, int[] parent) {

	if (parent[i] == -1)
		return i;
	return findParent(parent[i], parent);
}

public static void main(String[] args) {
	List<Circle> circles = new ArrayList<>();
	circles.add(new Circle(1, 2, 4));
	circles.add(new Circle(3, 7, 5));
	circles.add(new Circle(2, 2, 4));
	CirclesBelongToSameComponenet c = new CirclesBelongToSameComponenet();
	boolean result = c.circleOfSameComponet(circles);
	System.out.println(result);
}
}


I Believe output like this
and the answer remains to be true for me

0
Reply
Share
Report
roxy93's avatar
roxy93
0
Last Edit: December 14, 2022 12:03 AM

Read More
Well this question will banned tomorrow, it took me some time to come up with this question, write it test it and learn how to asked it properly and now I find it in leetcode :'(, Thank you man and good luck.
PS: I've seen multiple answers in the comment section and the intersection condition is false, the distance between the centers needs to be higher than (abs(r1-r2) for ex a circle inside another one do not intersect) and less that (r1+r2).

0
Reply
Share
Report
vinayak_jaiswal_'s avatar
Vinayak Jaiswal
2
August 1, 2022 10:16 PM

Read More
Have you got selected?

0
Reply
Share
Report
apdaksha's avatar
Aditya Pratap
0
July 27, 2022 3:37 PM

Read More
Same question was asked to me as well. As a follow up, interviewer asked to find largest group also if groups are disconnected. Solved using DFS. Got rejected, call is scheduled for feedback.

0
Show 3 replies
Reply
Share
Report
vkonatha's avatar
Venkatesh

54
May 20, 2022 11:58 PM

Read More
which location?

0
Reply
Share
Report

https://leetcode.com/discuss/interview-question/2025984/Google-Software-Engineer-Elimination-Round-Question
Google Software Engineer Elimination Round Question
1
Anonymous User
Anonymous User
May 10, 2022 7:53 PM

407 VIEWS

I had my elimination round with Google in January 2022, and I got rejected. The below question was asked to me, I wanted to know the solution to it.


We have series of animal cages like cage1, cage2, cage3 and so on. Each cage is fitted with security system, so that whenever an animal leaves it's cage,
the system starts triggering an alarm.
Whenever an alarm is triggered, the neighbouring cages animal start shouting, and this goes on for all continous neighbours(who are occupied).
Given a list of cages which need to be vacated, find the optimum order of vacating the cages. The optimality of the order is determined by the number of treats given.


Input : 7, [2, 7]
Output = [2, 7]

google
interview question
india
Comments: 2
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
v0011's avatar
v0011

43
May 16, 2022 1:19 PM

Read More
can you explain about the input and output ?

1
Show 1 reply
Reply
Share
Report
ershivasoni's avatar
Shiva soni

344
Last Edit: May 10, 2022 8:30 PM

Read More
TC O(nnn) Sc O(n*n)


Completing the question with assumption that we need to give treat to shouting animals to calm down after each alarm
dp[i][j] stores. {cage number, total treats} for (i,j) segment
dp[i][j] = j-i+1 + dp[i][k-1] + dp[k+1][j]. K which gives minimum value is cage number.
call dp[0][n-1] -> get cage numebr optimal -> vacant it -> recurse on dp[i][k-1] and dp[k+1][n] . once we vacant k cage number we get two separate segments (0,k-1) and (k+1,n-1) and we can proceed with any segment for ordering as both are exclusive independent.
0
Show 1 reply
Reply
Share
Report

https://leetcode.com/discuss/interview-question/2010312/Google-Interview-or-Screening-round
Google Interview | Screening round
1
Anonymous User
Anonymous User
Last Edit: May 7, 2022 11:00 PM

417 VIEWS

Given a n*n matrix where when we travel horizontally(i.e from one column to another) the starting probablity to reach a point initially is 90% and eventually it keeps reducing by half. When we traverse vertically the probablity initially is 50% and eventually it keeps reducing by half. Find the total probablity to traverse the given path.


Path: (0 1) -> (0 2) -> (1 2) -> (2 2) -> (2 1)

           90%   45%  22.5%
Input : [ (0,0) (0 1) (0 2)   50%    
		  (1,0) (1 1) (1 2)   25%
		  (2,0) (2 1) (2 2) ] 12.5%
			
			
For e.g : Probability to travel from 0,1 -> 0,2 is 22.5%, for 0,2 -> 1,2 is 25 % , from 1,2 to 2 2 is  12.5% and so on.
google
leetcode
india
premium member
Comments: 3
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
himan27's avatar
himan27

97
May 5, 2022 7:03 PM

Read More
Thanks for sharing. One clarification: Based on the input, it looks like, probability of reaching (0,0) : 90%, (0,1): 45%, (0,2): 22.5%, but the example portrays a different relation
"Probability to travel from 0,1 -> 0,2 is 45%, for 0,2 -> 1,2 is 50 % , from 1,2 to 2 2 is 25% and so on." as here we are not considering 22.5% to reach (0,2).


Also can you please share the expected output for the given input, it would be really helpful.

1
Show 1 reply
Reply
Share
Report
agnii's avatar
Agnieszka

28
May 6, 2022 2:07 AM

Read More
looks like a variation of https://leetcode.com/problems/path-with-maximum-probability/

0
Reply
Share
Report
yash04g's avatar
Yash Gupta

345
May 5, 2022 8:29 PM

Read More
Djikstra

https://leetcode.com/discuss/interview-question/1996656/Google-Phone-screen-round

Google Phone screen round
6
Anonymous User
Anonymous User
Last Edit: May 1, 2022 11:22 AM

3.0K VIEWS

Given few football teams. These teams belong to different countries and different groups. This will be given as a list of list in input (not list of pairs). Teams from same country and same team can't compete with each other.
You need to return pair of each team which can compete with other.


Country {
	italy: [1,2],
	Germany: [3,4],
}
Groups: {
	[1,4], [2,3]
}
Ans :
[
[1,3], [2,4]
]
What do you think is the most optimal approach?

google
india
phone screen
Comments: 10
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
kushvijay38's avatar
Kushal Vijay

17
May 4, 2022 11:49 PM

Read More
Create 2 maps, One for country and one for group. Assign country and Groups to each team via integers separately.
For Example: Assume Italy as 0, Germany as 1
Similarly, Group 1 as 0, Group 2 as 1
Maps will look like this: {1:0, 2:0, 3:1, 4:1}, {1:0,2:1,3:1,4:0}
Now create a matrix for Teams 4X4, fill the diagonal with 0 and for rest check for this condition


if( !(country[i] ==country[j]) && !(group[i]==group[j]) mat[i][j] =1;
else mat[i][j] = 0;


return the pairs with 1 from matrix.

13
Show 1 reply
Reply
Share
Report
gourav_gunjan's avatar
Gourav

36
May 1, 2022 12:29 PM

Read More
It seems like this is a graph problem. (or hashmap)
each member, like in this case, we can build adjacent nodes, from 1 to 2 and 4. That means 1 cannot compete with 1 and 4.


So if we do it for all members, we have a hashmap where we have key as a member and Set of values which are the teams it cannot compete with. (adj matrix)
Now we take each member from graph and out of all teams, we can create item arrays that a team can play with (not present in its adj matrix)
Will that work?


Time complexity seems to be:
For creating the matrix, O(nm) + O(m+k) -> n being size of country list, m being size of list of each country. Similar for m and k for Groups.
For compiling results, O(mm) -> for each team, we have check other team members.


I guess we can still optimise it though. This is just off my head.

1
Show 1 reply
Reply
Share
Report
VitoPagone's avatar
VitoPagone

0
October 22, 2024 6:37 PM

Read More
I solved it this way:
'''country = {
"Italy": [1, 2],
"Germany": [3, 4]
}
groups = [
[1, 4],
[2, 3]
]


possible_pairs = []
country_names = list(country.keys())
for i in range(len(country_names)):
for j in range(i+1, len(country_names)):
country1 = country_names[i]
country2 = country_names[j]


    for team1 in country[country1]:
        for team2 in country[country2]:
            possible_pairs.append([team1,team2])
for i in range(len(groups)):
for pair in possible_pairs:
if pair[0] in groups[i] and pair[1] in groups[i]:
possible_pairs.remove(pair)'''

0
Reply
Share
Report
Dendi_'s avatar
Dendi

160
Last Edit: February 17, 2023 2:09 AM

Read More
I think this question is very very similar to https://leetcode.com/problems/possible-bipartition/ this problem. Basically we just need to populate the dislike's graph and then the rest is same as below code. The for loop where I am printing the visited array. output of it would look like 1,-1,1,-1 (for the given test case) now what this output indicates is that all the indices with same value can compete with one another. 0th index(1st person) can compete with 2nd index(3rd person) and 1st index(2nd person) can compete with 3rd index(4th person). Please correct me if wrong.


public boolean possibleBipartition(int n, int[][] dislikes) {
    
    if(dislikes.length <= 1){
        return true;
    }
    Map<Integer, List<Integer>> g = new HashMap<>();
    
    for(int i=0;i<n;i++){
        g.put(i, new ArrayList<Integer>());
    }
    for(int[] dis : dislikes){
        g.get(dis[0]-1).add(dis[1]-1);
        g.get(dis[1]-1).add(dis[0]-1);
    }
    
    int[] visited = new int[n];
    
    for(int i=0;i<n;i++){
        if(visited[i] == 0 && !dfs(g, i, 1, visited)){
            return false;
        }
    }
    
    //here you will see output as [1,-1,1,-1]
    for(int i=0;i<n;i++){
        System.out.println(visited[i]);
    }
    return true;
}

private boolean dfs(Map<Integer, List<Integer>> g, int src, int group, int[] visited){
    
    visited[src] = group;
    
    for(int neighbor : g.get(src)){ 
        if(visited[neighbor] == group){
            return false;
        }
        if(visited[neighbor] == 0 && !dfs(g, neighbor, -group, visited)){
            return false;
        }
    }
    
    return true;
}
0
Reply
Share
Report
elismoer's avatar
elismoer
-1
September 28, 2022 11:45 AM

Read More
A match is played by teams, each with a maximum of eleven gamers; one must be the goalkeeper. A suit might not start or continue if either crew has fewer than seven gamers like บอลวันนี้.

0
Reply
Share
Report
harsha1296's avatar
Sri Harsha

36
July 25, 2022 1:32 PM

Read More
I think Disjoint set union (DSU)/ Union find data structure naturally fits in here since we want to take decisions based on if we belong to the same group or not. I believe the following approach would work


Create disjoint sets for each of the countries like {1, 2} and {3, 4}
Similarly create disjoint sets for each of the groups like {1, 4} and {2, 3}


Now lets go over each of the teams one by one and check in both country and group sets as follows :-


For 1, go through each of the other teams and pair them with it if they don't belong to the same set as 1 in both country and group sets
2 no -> same country
3 yes -> not present in the same set as 1 in both the sets
4 no -> same group


Similarly continue for other teams as well in only forward direction since previous elements would already have been paired


Time complexity :- Forming sets - O(n) - traversing through the input + O(n^2) for checking and pairing => this is the minimum as in the worst case we have to pair with all the remaining teams


Space complexity :- For sets - O(n)


Let me know your thoughts if this works !

0
Reply
Share
Report
deepkhajanchi's avatar
Deep

44
June 23, 2022 7:03 AM

Read More
I couldn't find similar question to this on leetcode, can one share it if that's available anywhere?

0
Reply
Share
Report
pg5295's avatar
pg5295

154
May 18, 2022 5:55 PM

Read More
Is better than n^2 complexity achievable here?

0
Show 1 reply
Reply
Share
Report
switchfast's avatar
switcher

8
May 2, 2022 5:57 AM

Read More
How about something like taking every pair of groups crossing their teams and skipping for the ones which belong to same team (O(1) lookup). Total run time complexity would be of order apx n*n (n-->total teams)

0
Reply
Share
Report
himan27's avatar
himan27

97
May 1, 2022 12:17 PM

Read More
Thanks for sharing. Curious to know what was your approach?

0
Reply
Share
Report
Copyright © 2024 LeetCode
Help Center
Jobs
Bug Bounty
Online Interview
Students
Terms
Priva

https://leetcode.com/discuss/interview-question/1511920/Google-Phone-Screening-for-L4-(Getting-Ready-for-Onsite-Interviews)


Google Phone Screening for L4 (Getting Ready for Onsite Interviews)
15
Anonymous User
Anonymous User
Last Edit: October 9, 2021 6:28 PM

3.7K VIEWS

Question 1
We have stream of incoming messages, each associated with timestamp. Print the unique messages within 10 seconds interval.


Similar to https://leetcode.com/problems/logger-rate-limiter/


Question was open ended and I had to ask many questions to frame it well. Came up with my own test cases, method definitions, assumptions and clarified it with interviewer.


Follow up (Tricky): Ignore any messages that are duplicated within 10 seconds interval.


Question 2
We have an array of nums with duplicates. Return true if there exists any duplicate number within d distance.


arr = [1,2,3,4,5,2] d=4
o/p = true;


In the above example, there is a duplicate present which is number 2 at index 1 and index 5. Distance b/w two numbers is the absolute difference between their indexes. In this case, it is 4 and which is matching the given criteria (i.e. d=4).


So our method should return true when the distance between duplicates is within the given criteria so following test cases will hold true as well,


arr = [1,2,3,4,2,5] d=4
o/p = true; //distance b/w 2s is 3


arr = [1,2,3,5,2,5] d=4
o/p = true; //distance b/w 5s is 2 and 2s is 3
Note: We can return true after encountering one pair of duplicates meeting our criteria


arr = [1,2,3,4,5,2] d=2
o/p = false; //distance b/w 2 is 4 but our criteria is 2 so return false

google
india
phone screening
Comments: 15
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
plee82's avatar
plee82
620
November 10, 2021 7:25 AM

Read More
I feel like the second problem is much better solved with a Hashmap.

9
Reply
Share
Report
RioR's avatar
Rio

12
Last Edit: November 10, 2021 12:14 AM

Read More
For Question 2-


Using Deque to determine sliding window and use set to find duplicate exist or not


Time Complexity o(n)
Space Complexity o(n)


{
    Deque<Integer> deque = new LinkedList<>();
    Set<Integer> set = new HashSet<>();
    for(int i=0;i<nums.length;i++)
    {
        if(!deque.isEmpty() && i-deque.peekFirst()>=distance)
        {
            int num = nums[deque.peekFirst()];
            deque.pollFirst();
            set.remove(num);
        }

        if(set.contains(nums[i]))
            return true;

        set.add(nums[i]);
        deque.offerLast(i);
    }

    return false;
}
4
Show 3 replies
Reply
Share
Report
rishabh0904's avatar
Rishabh Singhal

1
September 29, 2022 7:04 PM

Read More
what can be the optimized approach for follow-up of the first question?

1
Reply
Share
Report
xAyBzC's avatar
xAyBzC
75
October 10, 2021 10:18 PM

Read More
Q2: Using sliding window and OrderedDict| O(N) Time | O(d) Space


def has_duplicate(nums, d):
            window = OrderedDict()
            for i, num in enumerate(nums):
                if num in window:
                    return True
                if len(window) == d - 1:
                    window.popitem(last = False)
                window[num] = i
            return False

1
Show 1 reply
Reply
Share
Report
richa5ingh's avatar
Richa

55
Last Edit: August 22, 2024 1:20 PM

Read More
+1 for Q1. Same question along with same follow up was asked in onsite round.

0
Show 1 reply
Reply
Share
Report
stella06's avatar
Kanchan M

12
Last Edit: February 14, 2024 12:22 PM

Read More
Any suggestion on optimization for Q1 solution :
two action in this question


1.first print the unique msg = using unordered map(hashtable)


remove old time msgs = using queue
unordered_map<string,int>mp;
queue<pair<string, int>>q;
bool run = true;
while(run){
pair<string,int>p = get_status();
string msg = p.first;
int currtime = p.second;
q.push({msg,currtime});
if(mp.find(msg) != mp.end()){
int oldtime = mp[msg];
if(currtime - oldtime <10){
//mp[msg] = time;
continue;
}
}
mp[msg] = time;
cout<<msg<<"\n";
int exptime = currtime - 10;
if(exptime>0){
while(!q.empty() && q.front().second <= exptime){
q.pop();
}
}
}

0
Show 1 reply
Reply
Share
Report
stella06's avatar
Kanchan M

12
January 18, 2024 8:04 PM

Read More
same Q1 question asked recently..

0
Reply
Share
Report
suryanshsh's avatar
Suryansh
36
November 8, 2023 1:16 AM

Read More
Intuition:


We will use a hash table to keep track of the messages that have been seen and their timestamps.
To efficiently check for duplicates, we can use a sliding window approach.
Approach:


Maintain a hash table where the key is the message and the value is the timestamp of the last time we saw this message.
When a new message arrives, check if the message is in the hash table and whether the current timestamp is within 10 seconds of the stored timestamp.
If it's a duplicate within the 10-second window, ignore it; otherwise, update the timestamp and process the message.
To handle the real-time aspect, use a Go channel to receive messages and a goroutine to process them.
Time and Space Complexity:


Time Complexity: O(1) for each message arrival, since hash table operations (insertion, search) are constant time on average.
Space Complexity: O(n), where n is the number of unique messages received in the 10-second window.
More Optimizations:


Implement a cleanup routine to remove old messages from the hash table that are outside of the 10-second window to save memory.
Use a goroutine that periodically checks for and removes messages older than 10 seconds.
Here is a high-level outline of the Go code that represents this solution:


package main

import (
	"sync"
	"time"
)

// Message represents a robot status message.
type Message struct {
	Content   string
	Timestamp time.Time
}

// Deduplicator holds the logic for message deduplication.
type Deduplicator struct {
	messages   map[string]time.Time
	mu         sync.Mutex
	msgChannel chan Message
}

// NewDeduplicator creates a new Deduplicator.
func NewDeduplicator() *Deduplicator {
	d := &Deduplicator{
		messages:   make(map[string]time.Time),
		msgChannel: make(chan Message),
	}
	go d.processMessages()
	return d
}

// ProcessMessage processes an incoming message.
func (d *Deduplicator) ProcessMessage(msg Message) {
	d.msgChannel <- msg
}

// processMessages handles the deduplication of messages.
func (d *Deduplicator) processMessages() {
	for msg := range d.msgChannel {
		d.mu.Lock()
		if lastSeen, ok := d.messages[msg.Content]; !ok || msg.Timestamp.Sub(lastSeen) > 10*time.Second {
			// New message or not a duplicate within 10 seconds.
			d.messages[msg.Content] = msg.Timestamp
			d.processNewMessage(msg) // This function would handle new, non-duplicate messages.
		}
		// If it's a duplicate within 10 seconds, ignore the message.
		d.mu.Unlock()
	}
}

// processNewMessage processes a new, non-duplicate message.
func (d *Deduplicator) processNewMessage(msg Message) {
	// Implement the logic to handle a new message here.
	// For example, display it to the user or log it.
}

func main() {
	// Example usage:
	d := NewDeduplicator()
	d.ProcessMessage(Message{Content: "Status: OK", Timestamp: time.Now()})
	// ... more messages
}
0
Reply
Share
Report
hunter09's avatar
Amber Kumar Das
12
August 2, 2022 2:32 AM

Read More
Q2) Looks to be Sliding window problem. But your example 2 with d=4 should give false. it will give true only when d=2. Other examples looks fine. Below is Java implementation:


 public  boolean containsDuplicate(int[] arr, int k){
        int i=0,j=0;
        while (j<arr.length){
            if((j-i)<k){
                j++;
            }else{
                if(arr[i]==arr[j]){
                    return true;
                }else{
                    i++;j++;
                }
            }
        }
        return false;
    }
0
Reply
Share
Report
IaPIwSIgR's avatar
Selza Singh

123
Last Edit: March 13, 2022 4:26 PM

Read More
I have few queries for second question:


Are the numbers in array are in fixed range?
If yes then we can maintain the array of fixed size with last seen and whenever the distance between present index and last seen index of the number is less than d return true


If No, then instead of array use Hashmap


0
Reply
Share
Report
Copyright © 2024 LeetCode
Help Center
Jobs
Bug Bounty
Online Interview
Students
T

https://leetcode.com/discuss/interview-question/1521932/Google-Onsite
Google Onsite
13
Anonymous User
Anonymous User
Last Edit: October 15, 2021 7:09 PM

10.1K VIEWS

Hi LeetCode Community,
I recently went through the google onsite interview. I had a total for 3 coding rounds and 1 behavioural. Below are the questions I was asked.


Coding Round 1:
Given 2 images as a 2d matrix of size MN And KN. Find maximum overlapping part i. maximum bottom rows of first matrix which matches with the top rows of the second matrix
Eg. Matrix 1
[1,2,3,4]
[3,4,2,5]
[1,2,4,1]


Matrix 2
[3,4,2,5]
[1,2,4,1]
[1,5,7,8]
[7,5,7,3]


In above example answer is 2


Coding Round 2:
It was similar to merge intervals https://leetcode.com/problems/merge-intervals/ but with a bit modification.
Given Starting intervals we'll get 2 type of queries


Add intervals
Search for a particular number
eg:
Given initial intervals as : [[1,3],[2,6],[8,10],[15,18]]
Q queries
[1 4 5] => 1 represent query of type 1 and 4-5 is interval
[2 2] => 2 represent query of type 2 search for element 2


Coding Round 3:
This was the exactly similar to https://leetcode.com/problems/shortest-distance-from-all-buildings/ with a slight modification.


Behavioural Round
I was asked basic questions related to my work and my experience


Thanks to this community I was able to went through the interview but still it is a long way for me.

google
india
onsite
Comments: 21
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
lagnes's avatar
Urik

22
Last Edit: October 17, 2021 3:12 AM

Read More
Q1: Looks like the elements are only single digit numbers?
I'd convert each row into an int or bigint. Then matrix1 becomes a list of integers, as does matrix2.
Now you just need to find the longest suffix of matrix1 that is also a prefix of matrix2. Kind of like the Knuth-Morris-Pratt preprocessing subroutine.

11
Reply
Share
Report
rishabhr0y's avatar
rishabhr0y
72
October 22, 2021 5:06 AM

Read More
1st question is similar to
https://leetcode.com/problems/maximum-length-of-repeated-subarray/

3
Show 1 reply
Reply
Share
Report
Study321's avatar
Study321

1
January 15, 2022 12:22 AM

Read More
First question can be solved using KMP and hashing in O( MN + KN)

2
Show 1 reply
Reply
Share
Report
Miss_S's avatar
Miss S
109
October 16, 2021 11:21 PM

Read More
 public class Main {
public static void main(String[] args) {
     int[][] bottom = {{1,2,3,4}, {3,4,2,5}, {1,2,4,1}};
     int[][] top = {{3,4,2,5}, {1,2,4,1}, {1,5,7,8}, {7,5,7,3}};
    // int[][] bottom = {{1,4,2,5}, {3,4,2,5}, {1,4,2,5},  {3,4,2,5}};
    // int[][] top = {{1,4,2,5}, {3,4,2,5}, {1,4,2,5},{3,4,2,5}, {7,5,7,3}};
    // int[][] top = {{1,4,2,5}, {3,4,2,5}};
    System.out.println(findNoOfOverlappingParts(bottom, top));
}

private static int findNoOfOverlappingParts(int[][] bottom, int[][] top){ 
    if(bottom.length==0||bottom[0].length==0||top.length==0||top[0].length==0){
        return 0;
    }
    Trie trie = new Trie();
    for(int i=0;i<bottom.length;i++){ //O(m*m*n) time, Suffix trie based approach
        trie.add(bottom, i);
    }
    int rowIndex = trie.search(top); //O(k*n) time
    return rowIndex==-1?0:bottom.length-rowIndex;
}

private static class Trie{
    TrieNode root = new TrieNode();
    public void add(int[][] matrix, int index){ 
        TrieNode temp = root;
        for(int i=index;i<matrix.length;i++){
            for(int j=0;j<matrix[0].length;j++){
                if(!temp.children.containsKey(matrix[i][j])){
                    temp.children.put(matrix[i][j], new TrieNode());
                }
                temp = temp.children.get(matrix[i][j]);
            }
        }
        temp.rowIndex = index;
    }
    
    public int search(int[][] matrix){
        TrieNode temp = root;
        int result = -1;
        for(int i=0;i<matrix.length;i++){
            for(int j=0;j<matrix[0].length;j++){
                if(!temp.children.containsKey(matrix[i][j])){
                    return result;
                }
                temp = temp.children.get(matrix[i][j]);
                if(temp.rowIndex!=null){
                    result = temp.rowIndex;
                }
            }
        }
        return result;
    } 
}

private static class TrieNode{
    HashMap<Integer, TrieNode> children = new HashMap();
    Integer rowIndex=null;
}
 }
3
Reply
Share
Report
chefpr7's avatar
Pritam Roy
62
Last Edit: October 22, 2021 12:55 PM

Read More
I think first question can be solved using KMP algorithm.
We can transform every row to a character, transforming the entire matrix into a string of size = rows
so we can reframe the question as finding the max overlap between two strings 's' and 't' such that some suffix of s is equal to some prefix of t.
We can construct a final string K = t + '#' + s, and calculate the prefix array of K and answer = prefix[s.length()+ t.length()+1]
Ofcourse I'm assuming we have enough distinct characters to represent the rows.

2
Show 2 replies
Reply
Share
Report
savecancel's avatar
kv1999
186
October 15, 2021 5:26 PM

Read More
first question trie?

2
Show 2 replies
Reply
Share
Report
nayan_000's avatar
Nayan Mathur

10
June 15, 2022 12:58 PM

Read More
Similar question to Coding Round 2:
https://leetcode.com/problems/count-integers-in-intervals/


For, searching a particular number you can simply binary search on the intervals.

1
Reply
Share
Report
joesyriac1107's avatar
joesyriac1107

105
May 12, 2022 5:23 PM

Read More
Q1 -> convert each array to string. then use two pointer method. We know the starting string for mat 2 would be upper bound in mat1 and ending string mat1 the lower bound for mat2. have pointers set apart in both arrays. if lengths match try matching the elements in between. If it doesn't match move both pointers inside. If lengths mismatch, move the longer pointer in,till you find matching length and compare

1
Reply
Share
Report
itachi_god's avatar
NAVNEET HINGANKAR

236
October 26, 2021 7:20 PM

Read More
Q1 . can be solved using KMP , my code for the same , solve each column individually and then take minimum of all the rows ,
Maximum of column will be the answer.
TC , SC: (( M + K) * N) , code link : https://ideone.com/dfGrzh


vector<int> get_pi(vector<int> pattern , vector<int> text) {
	pattern.emplace_back(-1);
	int n = pattern.size() , m = text.size() ;
	for(int &x: text) pattern.emplace_back(x);
	vector<int> pi(n + m + 1);
	for(int i = 1 ; i < (int)pi.size() ; i++) {
		int j = pi[i - 1];
		while(j > 0 and pattern[j] != pattern[i]) 
		 j = pi[j - 1];
		 if(pattern[j] == pattern[i]) 
			j++;
		pi[i] = j;
	}
	return vector<int>(begin(pi) + n + 1, end(pi));
}

int solve(vector<vector<int>> &matrix1 , vector<vector<int>> &matrix2) {
	int n = matrix1.size() , m = matrix1[0].size() , k = matrix2.size();
	vector<int> MaxUntilNow(n, (int)1e9);
	for(int i = 0 ; i < m; i++) {
		vector<int> text, pattern;
		for(int j = 0; j < k; j++) pattern.emplace_back(matrix2[j][i]);
		for(int j = 0; j < n; j++) text.emplace_back(matrix1[j][i]);
		auto prefixList = get_pi(pattern , text);
		for(int j = 0 ; j < (int)prefixList.size() ; j++ )
			MaxUntilNow[j] = min(MaxUntilNow[j], prefixList[j]);
	}
	return *max_element(begin(MaxUntilNow), end(MaxUntilNow));
}
1
Reply
Share
Report
shivbaba's avatar
Rja

162
October 24, 2021 1:11 PM

Read More
In Coding Round 2, 2nd point, What do we return? Bool to denote whether 2 is present or not? Or do we return the actual single interval in which 2 lies, after all overlapping intervals have already been merge?

1
Reply
Share
Report
Copyright © 2024 LeetCode
Help Center
Jobs
Bug Bounty
Online Intervi

https://leetcode.com/discuss/interview-question/1531250/Google-or-Phone-Screen-or-Pairs-of-Non-overlapping-Subarrays
Google | Phone Screen | Pairs of Non-overlapping Subarrays
6
Anonymous User
Anonymous User
Last Edit: November 18, 2021 12:26 PM

1.9K VIEWS

Warm-up Question:
Find the total number of subarrays present in an array.


Main Question:
Find the total number of pairs of non-overlapping subarrays present in an array.


Cleared the phone screen. Will soon share the onsite experience.

google
india
phone-interview
phonescreen
Comments: 7
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
tuturu's avatar
Shiina Mayuri
26
Last Edit: October 23, 2021 1:01 PM

Read More
This should solve both the parts.


/* O(1) */
private int totalSubarrays(int n) {
    return n*(n+1)/2;
}

/* O(n) */
private int nonOverlappingSubarrays(int n) {
    int count = 0;
    for(int i=1;i<n;++i) {
        // count += totalSubarrays(i) * totalSubarrays(n-i);    /* repetitive */
        count += (i+1) * totalSubarrays(n-i);
    }
    return count;
}
The second part can also be done in O(1) but not required.

5
Show 6 replies
Reply
Share
Report
lagnes's avatar
Urik

22
October 22, 2021 1:16 PM

Read More
Why are they asking math questions

3
Show 1 reply
Reply
Share
Report
feynman_1729_67's avatar
sparsh
40
January 1, 2022 7:07 PM

Read More
nC4+nC2+2*(nC3)

0
Reply
Share
Report
big-whoop's avatar
big-whoop

563
December 9, 2021 5:10 AM

Read More
Nicely done, would you mind letting us know for which location was this? Thank you.

0
Show 1 reply
Reply
Share
Report
soulfall's avatar
Rahmania Astrid
2
October 23, 2021 1:12 PM

Read More
Hi, can you elaborate on the main question as well as example input output?


Is it given array = [1, 2, 3]
one example pair of non-overlapping subarray -> [1,2] & [3] ?

0
Show 2 replies
Reply
Share
Report
vidushi2504's avatar
vidushi2504
0
October 21, 2021 11:11 AM

Read More
What is the time complexity for the optimized approach of the main question?

0
Show 3 replies
Reply
Share
Report
hanuman22's avatar
rein

68
October 20, 2021 8:05 PM

Read More
YOE ??

0
Show 1 reply
Reply
Share
Report

https://leetcode.com/discuss/interview-question/1531831/Google-Fresh-Graduates-Onsite-Interviews
Google Fresh Graduates Onsite Interviews
1
Anonymous User
Anonymous User
October 20, 2021 10:32 PM

1.4K VIEWS

Hey Nooglers, I am having interview lined up for Google India SWE fresh graduates it would be really helpful if you could share some important and recently asked questions that I should practice before my interviews.


I am unable to see any recent interview experience on Leetcode where questions are nicely written. Kindly help me.

google
india
onsite
google-prep
phone screening
interview prep
Comments: 3
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
Robertmax87's avatar
Robertmax87
-3
December 30, 2021 1:32 AM

Read More
Text Justification
33.6%
Hard
Number of Digit One
32.9%
Hard
Alien Dictionary
34.4%
Hard
Bulls and Cows
46.5%
Medium
Russian Doll Envelopes
39.4%
Hard
Logger Rate Limiter
74.3%
Easy
Find Leaves of Binary Tree
76.3%
Medium
Shuffle an Array
56.3%
Medium
Longest Absolute File Path
45.2%
Medium
Split Array Largest Sum
49.1%
Hard
Sentence Screen Fitting
35.1%
Medium
Student Attendance Record II
39.9%
Hard
Longest Line of Consecutive One in Matrix
48.6%
Medium
Valid Square
43.7%
Medium
Find Duplicate Subtrees
55.1%
Medium
Split Array into Consecutive Subsequences
45.2%
Medium
Strange Printer
44.2%
Hard
Employee Importance
62.5%
Medium
Minimum Window Subsequence
42.9%
Hard
Asteroid Collision
44.3%
Medium
Prefix and Suffix Search
36.0%
Hard
Swap Adjacent in LR String
36.0%
Medium
Number of Matching Subsequences
50.2%
Medium
Find And Replace in String
53.5%
Medium
Guess the Word
43.8%
Hard
Car Fleet
47.2%
Medium
RLE Iterator
58.0%
Medium
Distinct Subsequences II
43.8%
Hard
Array of Doubled Pairs
37.7%
Medium
Time Based Key-Value Store
53.0%
Medium
Satisfiability of Equality Equations
49.3%
Medium
Longest String Chain
57.3%
Medium
Snapshot Array
37.1%
Medium
Longest Arithmetic Subsequence of Given Difference
49.6%
Medium
Count Square Submatrices with All Ones
74.0%
Medium
Minimum Number of Flips to Convert Binary Matrix to Zero Matrix
71.1%
Hard
Shortest Path in a Grid with Obstacles Elimination
43.8%
Hard
Divide Array in Sets of K Consecutive Numbers
56.1%
Medium
Minimum Cost to Make at Least One Valid Path in a Grid
60.0%
Hard
Maximum Points You Can Obtain from Cards
49.6%
Medium
Max Value of Equation
46.9%
Hard
Minimum Difference Between Largest and Smallest Value in Three Moves
56.2%
Medium
Number of Good Ways to Split a String
70.9%
Medium
Maximum Number of Visible Points
35.3%
Hard
Single-Threaded CPU
39.1%
Medium
Minimize Maximum Pair Sum in Array
80.3%
Medium
Maximum Number of Points with Cost
33.6%
Medium
Find Original Array From Doubled Array
35.5%
Medium
Detect Squares
39.5%
Medium
Stock Price Fluctuation
3
Reply
Share
Report
yash2711's avatar
Yash Halgaonkar

158
October 21, 2021 3:28 PM

Read More
Did you get this opportunity off campus or on campus?

0
Reply
Share
Report
vidushi2504's avatar
vidushi2504
0
October 21, 2021 11:59 AM

Read More
Did you find any recent questions?

0
Show 2 replies
Reply
Share
Report

https://leetcode.com/discuss/interview-question/1568857/Google-or-Phone-or-Is-path-possible-less-than-threshold

Problems
Contest
Discuss
Interview
Store
0

avatar
Back
Google | Phone | Is path possible less than threshold
8
Anonymous User
Anonymous User
Last Edit: November 13, 2021 5:56 PM

1.8K VIEWS

Position: L3 at Google India
YOE : New Grad


Thank you Leetcode Community! Yesterday I had my first telephonic interview with Google India. Only 1 question was asked.


Given a gird of MxN cells, with Integer cell values, we can define a path effort of a path from source (0,0) to the destination (M-1, N-1) as the max of the absolute differences of the adjacent cell values. While traversing, you can move up, down, left and right — 4 moves from the current cell in the grid. For a given Threshold value, find if it is possible to have a path in such a matrix with the effort not greater than the threshold value, from source to destination.


Example:
If we have a 3x3 matrix as follows -
[[1, 2, 3],
[4, 5, 6],
[7, 8, 9]]
Threshold = 4
Result: YES
As, 1->2->3->6->9 or 1->2->5->6->9 or ...


#include<bits/stdc++.h>
using namespace std;
int dir[4][2] = {{-1,0},{1,0},{0,1},{0,-1}};
bool isPossible(int x,int y,int rows,int cols){
	if(x < 0 or x >= rows or y < 0 or y >= cols) return 0;
	return 1;
}

bool dfs(vector<vector<int> > &grid,int x,int y,int &rows,int &cols,int threshold,vector<vector<int> > &visited){
	if(x == rows-1 and y == cols-1){
		return 1;
	}
	visited[x][y] = 1;
	for(int k = 0;k < 4;k++){
		int nx = x + dir[k][0];
		int ny = y + dir[k][1];
		if(isPossible(nx,ny,rows,cols) and abs(grid[nx][ny]-grid[x][y]) <= threshold and !visited[nx][ny]){
			int ans = dfs(grid,nx,ny,rows,cols,threshold,visited);
			if(ans) return 1;
		}
	}
	return 0;
}

int main(){
	int rows,cols,threshold;
	cin>>rows>>cols>>threshold;
	vector<vector<int> > grid(rows,vector<int>(cols));
	vector<vector<int> > visited(rows,vector<int>(cols,0));
	for(int i=0;i<rows;i++){
		for(int j=0;j<cols;j++){
			cin>>grid[i][j];
		}
	}
	bool ans = dfs(grid,0,0,rows,cols,threshold,visited);
	if(ans) cout<<"YES"<<endl;
	else cout<<"NO"<<endl;
} 
TC : O(n^2)
SC : O(n^2)
I wrote a code similar to this, Is my approach correct.
I was also thinking of using dp to store the answer at any given x,y.
Similar to this


#include<bits/stdc++.h>
using namespace std;
int dir[4][2] = {{-1,0},{1,0},{0,1},{0,-1}};
bool isPossible(int x,int y,int rows,int cols){
	if(x < 0 or x >= rows or y < 0 or y >= cols) return 0;
	return 1;
}
bool visited[105][105];
bool dfs(vector<vector<int> > &grid,int x,int y,int &rows,int &cols,int threshold,vector<vector<int> > dp){
	if(x == rows-1 and y == cols-1){
		return 1;
	}
	if(dp[x][y] != -1){
		return dp[x][y];
	}
	visited[x][y] = 1;
	int ans = 0;
	for(int k = 0;k < 4;k++){
		int nx = x + dir[k][0];
		int ny = y + dir[k][1];
		if(isPossible(nx,ny,rows,cols) and abs(grid[nx][ny]-grid[x][y]) <= threshold and !visited[nx][ny]){
			ans |= dfs(grid,nx,ny,rows,cols,threshold,dp);
		}
	}
	return dp[x][y] = ans;
}

int main(){
	int rows,cols,threshold;
	cin>>rows>>cols>>threshold;
	vector<vector<int> > grid(rows,vector<int>(cols));
	vector<vector<int> > dp(rows,vector<int>(cols,-1));
	for(int i=0;i<rows;i++){
		for(int j=0;j<cols;j++){
			cin>>grid[i][j];
		}
	}
	bool ans = dfs(grid,0,0,rows,cols,threshold,dp);
	if(ans) cout<<"YES"<<endl;
	else cout<<"NO"<<endl;
}
Which approach is better.
TC : O(n^2)
SC : O(n^2)


Also interviewer asked which approach is better dfs or bfs? I said dfs as, as soon we get the result we will return true, while in bfs we may have to explore a lot of options as it is level wise so only at the end level we will reach m-1,n-1.


I gave the 1st approach as solution in the interview, 2nd approach is just for my own knowledge.
Waiting for the telephonic result.
**Edit: **
I cleared the telephonic rounds. But the recruiter said work on your communication a little. Can someone provide any tips regarding the same?

google
india
phone screening
Comments: 12
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
AgunJol's avatar
AgunJol

60
November 10, 2021 2:28 AM

Read More
I like the first approach. I assume it was a great/positive interview!


I do not see how your memoization/dp can help. It can only help if your partial results from previous dfs at level x could have been used in next dfs. I do not see that here (as the results are boolean and you only want one solution). A visited array is sufficient.

3
Reply
Share
Report
Oliver_Xia2021's avatar
Oliver

85
December 1, 2021 9:36 AM

Read More
You can also do this with Union Find.
Generate all edges and cost (namely, (i,j) --> (i+dx, j+dy) for all four directions)
sort [edge, cost] by cost and then union nodes from small cost to thresh hold.
And Check if the left top and right bottom node is in the same component every time


There are 4N edges, where N is the number of nodes
Sort takes NlogN time and then union-find take lgN time for each edge (lg is the inverse Ackerman function, it's faster than logN on average)
so in total O(NlogN)

1
Reply
Share
Report
avikef's avatar
avikef

1
November 11, 2021 12:25 PM

Read More
Why is the the time complexity n^2?

1
Reply
Share
Report
balu_r's avatar
Balasubramaniam R

113
November 10, 2021 10:00 AM

Read More
how many days after applying did you hear back from recruiter?

1
Show 1 reply
Reply
Share
Report
mprashker12's avatar
mprashker12

17
November 10, 2021 5:40 AM

Read More
dp doesn't seem to help here because we can move in any 4 directions, so it is not clear in what order to process the cells when filling up the dp table. Instead, I would view this as a disjoint union problem. View cells as vertices and edges connect adjacent cells in the grid. Initially, each vertex is in its own component. Then we iterate over every single edge. If that edge has weight less than the given threshold, then we perform a merge of the two components which the cells on each side of the edge belong to. At the end, we just check if (0,0) and (m - 1, n - 1) belong to the same component. If we implement the disjoint union find well (use path compression and only merge smaller to larger (https://cp-algorithms.com/data_structures/disjoint_set_union.html), then all merge operations take essentially constant time, so the overall runtime is essentially just the number of edges in the graph, which is O(n^2)

1
Reply
Share
Report
depressed123's avatar
depressed123
10
December 2, 2021 2:28 PM

Read More
Hey, are your onsites over?

0
Show 1 reply
Reply
Share
Report
RioR's avatar
Rio

12
November 29, 2021 1:06 AM

Read More
Time complexity is o(n) (Total number of element present in matrix) because you are visiting the node one time...

https://leetcode.com/discuss/interview-question/1584626/Google-India-or-Phone-Screen
Google India | Phone Screen
4
munish_c's avatar
Munish
7
Last Edit: November 18, 2021 5:24 PM

1.4K VIEWS

I just went through a Google Hangout Interview.


Question:
We have one webserver which is serving large requests per second let's say 50K. Along with each request, we know the IP address of the connected user.
We have one database(you can assume any) which has information on the IP address range and its city name.


eg.
100.100.100.100 - 200.200.200.200 belongs to banglore.
101.100.100.100 - 201.200.200.200 belongs to mumbai.


We need to implement the function which has input as an IP address(IPv4) and output as city name.
As max 4 billion IP addresses are available in IPv4 so let's consider we have 1billion ranges (same city can have multiples ranges). How can we do a lookup in constant time?


Please share your most optimal approaches in the solution.

google
india
phone screening
Comments: 3
BestMost VotesNewest to OldestOldest to Newest
Type comment here... (Markdown is supported)

Preview

Post
workHardAndSmart's avatar
work hard and smart

83
Last Edit: December 3, 2021 7:47 PM

Read More
Dose 101.100.100.100 belong to 100.100.100.100 - 200.200.200.200 range ?
Because next IP of 100.100.100.100 is 100.100.100.101. And follow's IPs are100.100.100.102 ..101.100.100.99, 101.100.100.100.. 199.256.256.256, 200.0.0.0, 200.0.0.1...200.200.200.200.

2
Reply
Share
Report
LC_Jesse's avatar
LC_Jesse
856
November 18, 2021 8:25 PM

Read More
Hi there!
If you could please edit the post title to the following layout: Company Name | Stage (Phone, Onsite, OA) | Question name
We ask that you can follow these guidelines here, thank you!

0
Reply
Share
Report
HiddenGuy's avatar
Hidden
333
Last Edit: November 18, 2021 7:02 PM

Read More
How about using a TRIE? IP address are 32BIT binary strings. We can insert the lower limits in the trie and store the higher limits in the Nodes and do a search. Need to devise the exact algorithm but definitely doable


What approach did you come up with and how was it perceived? Was it the most optimal?

-2
Show 1 reply
Reply
Share
Report